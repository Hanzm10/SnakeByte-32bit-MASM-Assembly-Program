Microsoft (R) Macro Assembler Version 14.44.35219.0	    11/11/25 10:50:39
snake.asm						     Page 1 - 1


				.386
				.model flat, stdcall
				.stack 4096
				ExitProcess PROTO, dwExitCode: DWORD
				INCLUDE Irvine32.inc
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C ;OPTION CASEMAP:NONE		; optional: make identifiers case-sensitive
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .MODEL flat, stdcall
c:\Irvine\SmallWin.inc(11) : warning A4011:multiple .MODEL directives found : .MODEL ignored
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C .NOLIST
			      C .LIST
			      C 

 00000000			.data
				; wall character and wall representation
 = 000000DB			wallChar EQU 219
				; create a string of wall characters for drawing horizontal walls
 00000000  00000046 [		xWall BYTE 70 DUP(wallChar),0
	    DB
	   ] 00

				; Variables for DrawScoreboard PROC
 00000047 53 63 6F 72 65	strScore BYTE "Score: ",0
	   3A 20 00
 0000004F 0000			score WORD 0

				; Variables for YouDied PROC
 00000051 54 72 79 20 41	strTryAgain BYTE "Try Again?  1=yes, 0=no",0
	   67 61 69 6E 3F
	   20 20 31 3D 79
	   65 73 2C 20 30
	   3D 6E 6F 00
 00000069 69 6E 76 61 6C	invalidInput BYTE "invalid input",0
	   69 64 20 69 6E
	   70 75 74 00
 00000077 20 70 6F 69 6E	strPoints BYTE " point(s)",0
	   74 28 73 29 00
 00000081 20 20 20 20 20	blank BYTE "                                     ",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 00
 000000A7 53 4E 41 4B 45	titleName BYTE "SNAKEBYTE",0
	   42 59 54 45 00

				; New death reason strings
 000000B1 59 6F 75 20 68	strWallDeath  BYTE "You hit the wall!",0
	   69 74 20 74 68
	   65 20 77 61 6C
	   6C 21 00
 000000C3 59 6F 75 20 68	strBodyDeath  BYTE "You hit your own body!",0
	   69 74 20 79 6F
	   75 72 20 6F 77
	   6E 20 62 6F 64
	   79 21 00
 000000DA 59 6F 75 20 68	strCollision  BYTE "You hit the hazard block!",0
	   69 74 20 74 68
	   65 20 68 61 7A
	   61 72 64 20 62
	   6C 6F 63 6B 21
	   00


				; Variables for FinishedGame PROC
 000000F4 43 6F 6E 67 72	strFinishedGame BYTE "Congratulations! You finished the game!",0
	   61 74 75 6C 61
	   74 69 6F 6E 73
	   21 20 59 6F 75
	   20 66 69 6E 69
	   73 68 65 64 20
	   74 68 65 20 67
	   61 6D 65 21 00
 0000011C 54 68 65 72 65	strNoMoreSpace BYTE "There's no more available space to place coin!",0
	   27 73 20 6E 6F
	   20 6D 6F 72 65
	   20 61 76 61 69
	   6C 61 62 6C 65
	   20 73 70 61 63
	   65 20 74 6F 20
	   70 6C 61 63 65
	   20 63 6F 69 6E
	   21 00

				; Snake representation
 0000014B 3E			snake BYTE ">", 104 DUP("*")
	   00000068 [
	    2A
	   ]
 000001B4 00000004		snakeBodyInit DWORD 4		; initial length of snake body (excluding head)

				; Arrays to hold the x and y positions of each snake segment
 000001B8 2D 2C 2B 2A 29	xPos BYTE 45,44,43,42,41, 500 DUP(wallChar)
	   000001F4 [
	    DB
	   ]
 000003B1 0F 0F 0F 0F 0F	yPos BYTE 15,15,15,15,15, 500 DUP(wallChar)
	   000001F4 [
	    DB
	   ]

				; Wall positions
 000005AA 19 19 5F 5F		xPosWall BYTE 25,25,95,95		;position of upperLeft, lowerLeft, upperRight, lowerRignt wall 
 000005AE 05 19 05 19		yPosWall BYTE 5,25,5,25

				; Coin position
 000005B2 00			xCoinPos BYTE ?
 000005B3 00			yCoinPos BYTE ?

				; Input handling
 000005B4 00			inputChar BYTE ?					; + denotes the start of the game
 000005B5 00			lastInputChar BYTE ?				

				; Speed control
 000005B6 00000078		baseSpeed   DWORD 120        ; starting delay in milliseconds
 000005BA 0000000A		topSpeed    DWORD 10         ; fastest possible delay
 000005BE 00000000		speed       DWORD ?          ; current speed (changes dynamically)
 000005C2 53 70 65 65 64	strSpeed    BYTE "Speed: ",0 ; optional display label
	   3A 20 00

				; Hazard block variables
 000005CA 00			hazardActive   BYTE 0      ; 0 = none, 1 = drawn and active
 000005CB 00			hazardOrient   BYTE 0      ; 0 = horizontal, 1 = vertical
 000005CC 00			hazardX        BYTE 0      ; base X
 000005CD 00			hazardY        BYTE 0      ; base Y
 = 0000000F			HAZARD_LEN     EQU 15
 = 00000006			HAZARD_CLOSE_DIST EQU 6  

				; Multiple hazard blocks
 = 00000005			MAX_HAZARDS   EQU 5
 000005CE 00			hazCount      BYTE 0
 000005CF  00000005 [		hazXs         BYTE MAX_HAZARDS DUP(0)
	    00
	   ]
 000005D4  00000005 [		hazYs         BYTE MAX_HAZARDS DUP(0)
	    00
	   ]
 000005D9  00000005 [		hazOrients    BYTE MAX_HAZARDS DUP(0)   ; 0 = horiz, 1 = vert
	    00
	   ]

 00000000			.code
 00000000			main PROC
 00000000  E8 00000293			call DrawWall			;draw walls

 00000005  A1 000005B6 R		mov eax, baseSpeed      ; puts the base speed which is 120 into eax
 0000000A  A3 000005BE R		mov speed, eax          ; puts the 120(now in eax) to speed variable

 0000000F  E8 00000315			call DrawScoreboard		;draw scoreboard

 00000014  BE 00000000		    mov esi,0               ; initialize index to 0
 00000019  B9 00000005			mov ecx,5               ; loop 5 times to draw initial snake

 0000001E			drawSnake:
 0000001E  E8 000003B4			call DrawPlayer			;draw snake(start with 5 units)
 00000023  46				inc esi                 ; increment index to draw next character(used by DrawPlayer PROC)
 00000024  E2 F8		    loop drawSnake          ; loop until ecx is 0 to draw all 5 characters

 00000026  E8 0000042F			call CreateRandomCoin   ; generate random coin position
 0000002B  E8 000003FD			call DrawCoin			;set up finish

 00000030				gameLoop::
 00000030  B2 6A				mov dl,106						;move cursor to coordinates
 00000032  B6 01				mov dh,1
 00000034  E8 00000000 E			call Gotoxy

						; get user key input
 00000039  E8 00000000 E			call ReadKey
 0000003E  74 11		        jz noKey						;jump if no key is entered
 00000040  8A 1D 000005B4 R			mov bl, inputChar
 00000046  88 1D 000005B5 R			mov lastInputChar, bl
 0000004C  A2 000005B4 R			mov inputChar,al				;assign variables

 00000051					noKey:
 00000051  80 3D 000005B4 R			cmp inputChar,"x"	
	   78
 00000058  0F 84 0000022C			je exitgame						;exit game if user input x

 0000005E  80 3D 000005B4 R			cmp inputChar,"w"
	   77
 00000065  0F 84 000000B4			je checkTop

 0000006B  80 3D 000005B4 R			cmp inputChar,"s"
	   73
 00000072  74 14				je checkBottom

 00000074  80 3D 000005B4 R			cmp inputChar,"a"
	   61
 0000007B  74 39				je checkLeft

 0000007D  80 3D 000005B4 R			cmp inputChar,"d"
	   64
 00000084  74 6B				je checkRight
 00000086  75 A8				jne gameLoop					; reloop if no meaningful key was entered


						; check whether can continue moving
 00000088					checkBottom:	
 00000088  C6 05 0000014B R			mov snake[0], 'v'
	   76
 0000008F  80 3D 000005B5 R			cmp lastInputChar, "w"
	   77
 00000096  0F 84 000001C8			je dontChgDirection		;cant go down immediately after going up
 0000009C  8A 0D 000005AF R			mov cl, yPosWall[1]
 000000A2  FE C9				dec cl					;one unit ubove the y-coordinate of the lower bound
 000000A4  38 0D 000003B1 R			cmp yPos[0],cl
 000000AA  0F 8C 000000D3			jl moveDown
 000000B0  0F 84 000001C5			je diedWall					;die if crash into the wall

 000000B6					checkLeft:		
 000000B6  C6 05 0000014B R			mov snake[0], '<'
	   3C
 000000BD  80 3D 000005B5 R			cmp lastInputChar, "+"	;check whether its the start of the game
	   2B
 000000C4  0F 84 000001A5			je dontGoLeft
 000000CA  80 3D 000005B5 R			cmp lastInputChar, "d"
	   64
 000000D1  0F 84 0000018D			je dontChgDirection
 000000D7  8A 0D 000005AA R			mov cl, xPosWall[0]
 000000DD  FE C1				inc cl
 000000DF  38 0D 000001B8 R			cmp xPos[0],cl
 000000E5  0F 8F 000000D2			jg moveLeft
 000000EB  0F 84 0000018A			je diedWall					; check for left	

 000000F1					checkRight:		
 000000F1  C6 05 0000014B R			mov snake[0], '>'
	   3E
 000000F8  80 3D 000005B5 R			cmp lastInputChar, "a"
	   61
 000000FF  0F 84 0000015F			je dontChgDirection
 00000105  8A 0D 000005AC R			mov cl, xPosWall[2]
 0000010B  FE C9				dec cl
 0000010D  38 0D 000001B8 R			cmp xPos[0],cl
 00000113  0F 8C 000000DE			jl moveRight
 00000119  0F 84 0000015C			je diedWall					; check for right	

 0000011F					checkTop:		
 0000011F  C6 05 0000014B R			mov snake[0], '^'
	   5E
 00000126  80 3D 000005B5 R			cmp lastInputChar, "s"
	   73
 0000012D  0F 84 00000131			je dontChgDirection
 00000133  8A 0D 000005AE R			mov cl, yPosWall[0]
 00000139  FE C1				inc cl
 0000013B  38 0D 000003B1 R			cmp yPos,cl
 00000141  7F 06				jg moveUp
 00000143  0F 84 00000132			je diedWall			; check for up	
						
 00000149					moveUp:		
 00000149  A1 000005BE R			mov eax, speed		;slow down the moving
						;add eax, speed
 0000014E  E8 00000000 E			call delay

 00000153  BE 00000000				mov esi, 0			;index 0(snake head)
 00000158  E8 000002B3				call UpdatePlayer
						
 0000015D  8A A6 000003B1 R			mov ah, yPos[esi]	
 00000163  8A 86 000001B8 R			mov al, xPos[esi]	;alah stores the pos of the snake's next unit 

 00000169  FE 8E 000003B1 R			dec yPos[esi]		;move the head up

 0000016F  E8 00000263				call DrawPlayer		

 00000174  E8 00000570				call DrawBody

 00000179  BE 00000000				mov esi, 0	;added
 0000017E  E8 00000524				call CheckSnake

						
 00000183					moveDown:			;move down
 00000183  A1 000005BE R			mov eax, speed
 00000188  E8 00000000 E			call delay

 0000018D  BE 00000000				mov esi, 0
 00000192  E8 00000279				call UpdatePlayer

 00000197  8A A6 000003B1 R			mov ah, yPos[esi]	
 0000019D  8A 86 000001B8 R			mov al, xPos[esi]

 000001A3  FE 86 000003B1 R			inc yPos[esi]

 000001A9  E8 00000229				call DrawPlayer

 000001AE  E8 00000536				call DrawBody

 000001B3  BE 00000000				mov esi, 0	 ;added
 000001B8  E8 000004EA				call CheckSnake


 000001BD					moveLeft:			;move left
 000001BD  A1 000005BE R			mov eax, speed
 000001C2  E8 00000000 E			call delay

 000001C7  BE 00000000				mov esi, 0
 000001CC  E8 0000023F				call UpdatePlayer

 000001D1  8A A6 000003B1 R			mov ah, yPos[esi]	
 000001D7  8A 86 000001B8 R			mov al, xPos[esi]

 000001DD  FE 8E 000001B8 R			dec xPos[esi]

 000001E3  E8 000001EF				call DrawPlayer

 000001E8  E8 000004FC				call DrawBody

 000001ED  BE 00000000				mov esi, 0	 ;added
 000001F2  E8 000004B0				call CheckSnake


 000001F7					moveRight:			;move right
 000001F7  A1 000005BE R			mov eax, speed
 000001FC  E8 00000000 E			call delay

 00000201  BE 00000000				mov esi, 0
 00000206  E8 00000205				call UpdatePlayer

 0000020B  8A A6 000003B1 R			mov ah, yPos[esi]	
 00000211  8A 86 000001B8 R			mov al, xPos[esi]

 00000217  FE 86 000001B8 R			inc xPos[esi]

 0000021D  E8 000001B5				call DrawPlayer

 00000222  E8 000004C2				call DrawBody

 00000227  BE 00000000				mov esi, 0	;added
 0000022C  E8 00000476				call CheckSnake

					; getting points
 00000231					checkcoin::
 00000231  BE 00000000				mov esi,0
 00000236  8A 1D 000001B8 R			mov bl,xPos[0]
 0000023C  3A 1D 000005B2 R			cmp bl,xCoinPos
 00000242  0F 85 FFFFFDE8			jne gameloop			;reloop if snake is not intersecting with coin
 00000248  8A 1D 000003B1 R			mov bl,yPos[0]
 0000024E  3A 1D 000005B3 R			cmp bl,yCoinPos
 00000254  0F 85 FFFFFDD6			jne gameloop			;reloop if snake is not intersecting with coin

 0000025A  E8 000004C3				call EatingCoin			;call to update score, append snake and generate new coin	

 0000025F  E9 FFFFFDCC		jmp gameLoop					;reiterate the gameloop


 00000264				dontChgDirection:		;dont allow user to change direction
 00000264  88 1D 000005B4 R		mov inputChar, bl		;set current inputChar as previous
 0000026A  E9 FFFFFDE2			jmp noKey				;jump back to continue moving the same direction 

 0000026F				dontGoLeft:				;forbids the snake to go left at the begining of the game
 0000026F  C6 05 000005B4 R		mov	inputChar, "+"		;set current inputChar as "+"
	   2B
 00000276  E9 FFFFFDB5			jmp gameLoop			;restart the game loop

 0000027B				diedWall::
 0000027B  E8 00000B84			call YouDiedWall          ; wall death handler

 00000280				diedBody::
 00000280  E8 00000C16			call YouDiedBody          ; body death handler
					 
 00000285				playagn::			
 00000285  E8 00000CA8			call ReinitializeGame			;reinitialise everything
					
 0000028A				exitgame::
					exit
 0000028A  6A 00	   *	    push   +000000000h
 0000028C  E8 00000000 E   *	    call   ExitProcess
				INVOKE ExitProcess,0
 00000291  6A 00	   *	    push   +000000000h
 00000293  E8 00000000 E   *	    call   ExitProcess
 00000298			main ENDP



 00000298			DrawWall PROC
 00000298  B8 00000004		    mov eax, red + (black * 16)     ; puts red color value in eax because SetTextColor uses eax
 0000029D  E8 00000000 E	    call SetTextColor       ; set text color to red

				    ; Upper
 000002A2  8A 15 000005AA R	    mov dl, xPosWall[0]     ; puts the value of the first element of xPosWall into dl(which is 10)
 000002A8  8A 35 000005AE R	    mov dh, yPosWall[0]     ; puts the value of the first element of yPosWall into dh(which is 5)
 000002AE  E8 00000000 E	    call Gotoxy     ; move cursor to (10,5)
 000002B3  BA 00000000 R	    mov edx, OFFSET xWall   ; puts the xWall(which is a duplicate of WallChar for 100x) into edx
 000002B8  E8 00000000 E	    call WriteString    ; writes the wall horizontally

				    ; Lower
 000002BD  8A 15 000005AB R	    mov dl, xPosWall[1]     ; puts the value of the second element of xPosWall into dl(which is 10)
 000002C3  8A 35 000005AF R	    mov dh, yPosWall[1]     ; puts the value of the second element of yPosWall into dh(which is 25)
 000002C9  E8 00000000 E	    call Gotoxy     ; move cursor to (10,25)
 000002CE  BA 00000000 R	    mov edx, OFFSET xWall   ; puts the xWall(which is a duplicate of WallChar for 100x) into edx
 000002D3  E8 00000000 E	    call WriteString    ; writes the wall horizontally

				    ; Right vertical (use local endY = yPosWall[1])
 000002D8  8A 15 000005AC R	    mov dl, xPosWall[2]     ; puts the value of the third element of xPosWall into dl(which is 110)
 000002DE  8A 35 000005B0 R	    mov dh, yPosWall[2]     ; puts the value of the third element of yPosWall into dh(which is 5)
 000002E4  B0 DB		    mov al, wallChar    ;puts wallChar into al because WriteChar uses al
 000002E6  8A 1D 000005AF R	    mov bl, yPosWall[1]       ; puts the value of the second element of yPosWall into bl(which is 25)
 000002EC			L11:
 000002EC  E8 00000000 E	    call Gotoxy     ; move cursor to (110, 5)
 000002F1  E8 00000000 E	    call WriteChar  ; writes the wallChar 
 000002F6  FE C6		    inc dh      ; increment dh to move down vertically
 000002F8  3A F3		    cmp dh, bl  ; compares dh value(that starts with 5, now 6 because of increment) to bl(which is 25)
 000002FA  7E F0		    jle L11     ; It will jump back to L11 if dh is less than or equal to bl(25)

				    ; Left vertical
 000002FC  8A 15 000005AA R	    mov dl, xPosWall[0]     ; puts the value of the first element of xPosWall into dl(which is 10)
 00000302  8A 35 000005AE R	    mov dh, yPosWall[0]     ; puts the value of the first element of yPosWall into dh(which is 5)
 00000308  B0 DB		    mov al, wallChar        ; puts wallChar into al because WriteChar uses al
 0000030A			L12:
 0000030A  E8 00000000 E	    call Gotoxy     ; move cursor to (10, 5)
 0000030F  E8 00000000 E	    call WriteChar  ; writes the wallChar
 00000314  FE C6		    inc dh      ; increment dh to move down vertically
 00000316  3A 35 000005AF R	    cmp dh, yPosWall[1]  ; compares dh value(that starts with 5, now 6 because of increment) to yPosWall[1](which is 25)
 0000031C  7E EC		    jle L12     ; It will jump back to L12 if dh is less than or equal to yPosWall[1](25)

 0000031E  B8 0000000F		    mov eax, white + (black * 16)  ; puts white color value in eax because SetTextColor uses eax
 00000323  E8 00000000 E	    call SetTextColor        ; reset text color to white on black
 00000328  C3			    ret     ; return from procedure
 00000329			DrawWall ENDP


 00000329			DrawScoreboard PROC				;procedure to draw scoreboard

 00000329  B8 0000000E		    mov eax, yellow + (black*16)     ; puts white color value in eax because SetTextColor uses eax
 0000032E  E8 00000000 E		call SetTextColor			; reset text color to white on black

 00000333  B2 38		    mov dl, 56		; puts 52 in dl to set x coordinate for the separator
 00000335  B6 02		    mov dh, 2		; puts 3 in dh to set y coordinate for the separator
 00000337  E8 00000000 E	    call Gotoxy     ; move cursor to (52,3)
 0000033C  BA 000000A7 R	    mov edx, OFFSET titleName    ; puts the string "SNAKEBYTE" into edx
 00000341  E8 00000000 E	    call WriteString    ; writes "SNAKEBYTE"

 00000346  8A 15 000005AA R		mov dl, xPosWall[0]        ; puts 10 in dl to set x coordinate
 0000034C  B6 04			mov dh,4        ; puts 4 in dh to set y coordinate
 0000034E  E8 00000000 E		call Gotoxy     ; move cursor to (10,4)

 00000353  BA 00000047 R		mov edx,OFFSET strScore     ; puts the string "Score: " into edx
 00000358  E8 00000000 E		call WriteString    ; writes "Score: "

 0000035D  66| A1			mov ax, score       ; puts score value into ax
	   0000004F R
 00000363  E8 00000000 E		call WriteInt		; writes the score value after "Score: "

 00000368  E8 0000000B		    call ShowSpeed      ; display speed level at the far right side

 0000036D  B8 0000000F		    mov eax, white + (black*16)     ; puts white color value in eax because SetTextColor uses eax
 00000372  E8 00000000 E		call SetTextColor			; reset text color to white on black

 00000377  C3				ret         ;return from procedure
 00000378			DrawScoreboard ENDP

 00000378			ShowSpeed PROC
 00000378  8A 15 000005AC R	    mov dl, xPosWall[2] ; puts 110 into dl to set x coordinate for speed display
 0000037E  80 EA 08			sub dl, 8        ; adjust left by 8 for spacing
 00000381  B6 04		    mov dh, 4   ; set y coordinate for speed display
 00000383  E8 00000000 E	    call Gotoxy     ; move cursor to (102,4)

 00000388  BA 000005C2 R	    mov edx, OFFSET strSpeed    ; puts "Speed: " into edx because WriteString uses edx
 0000038D  E8 00000000 E	    call WriteString        ; writes "Speed: "
				    
				    ; Calculate speed level: (baseSpeed - currentSpeed) / 10
				    ; This shows 0 at start, then 1, 2, 3... as you get faster
 00000392  A1 000005B6 R	    mov eax, baseSpeed        ; puts the value of the baseSpeed(120) into eax
 00000397  2B 05 000005BE R	    sub eax, speed            ; subs the current speed from baseSpeed
 0000039D  B9 0000000A		    mov ecx, 10         ; puts 10 into ecx for division
 000003A2  33 D2		    xor edx, edx        ; clear edx before division
 000003A4  F7 F1		    div ecx                   ; divides eax by ecx(10), so the result is not big like 120, but smaller, starting from 0,1,2...
 000003A6  E8 00000000 E	    call WriteInt             ; Writes the speed level from eax
				    
 000003AB  C3			    ret     ;return from procedure
 000003AC			ShowSpeed ENDP

 000003AC			UpdateSpeed PROC
				    ; Update speed every 3 points
 000003AC  0F B7 05		    movzx eax, score          ; Load score (now WORD)
	   0000004F R
 000003B3  B9 00000003		    mov ecx, 3
 000003B8  33 D2		    xor edx, edx
 000003BA  F7 F1		    div ecx                   ; eax = score / 3, edx = remainder
 000003BC  83 FA 00		    cmp edx, 0
 000003BF  75 15		    jne skipUpdate            ; Only update when score is divisible by 5

				    ; Decrease delay by 10ms (makes game faster)
 000003C1  A1 000005BE R	    mov eax, speed
 000003C6  3B 05 000005BA R	    cmp eax, topSpeed         ; Check BEFORE subtracting
 000003CC  7E 08		    jle skipUpdate            ; Already at max speed, don't go lower
				    
 000003CE  83 E8 0A		    sub eax, 10               ; Reduce delay = increase speed
 000003D1  A3 000005BE R	    mov speed, eax

 000003D6			skipUpdate:
 000003D6  C3			    ret
 000003D7			UpdateSpeed ENDP


 000003D7			DrawPlayer PROC			    ; draw player at (xPos,yPos)

 000003D7  50				push eax                ; pushes the value of eax(the current color) onto the stack
 000003D8  52				push edx                ; pushes the value of edx(the current position) onto the stack
					
 000003D9  B8 0000000A			mov eax, lightGreen + (black * 16)  ; puts light green color value in eax
 000003DE  E8 00000000 E		call SetTextColor       ; set text color: green on black 

 000003E3  8A 96 000001B8 R		mov dl,xPos[esi]        ; puts the x position of the snake segment at index esi into dl
 000003E9  8A B6 000003B1 R		mov dh,yPos[esi]        ; puts the y position of the snake segment at index esi into dh
 000003EF  E8 00000000 E		call Gotoxy             ; move cursor to (xPos, yPos)

 000003F4  8A D0			mov dl, al              ; puts al value() into dl to temporarily save it
 000003F6  8A 86 0000014B R		mov al, snake[esi]      ; puts the character representing the snake segment at index esi into al because WriteChar uses al
 000003FC  E8 00000000 E		call WriteChar          ; writes the character at (xPos, yPos)
 00000401  8A C2			mov al, dl	            ; restores al from dl

 00000403  B8 0000000F			mov eax, white + (black*16) ; puts white color value in eax because SetTextColor uses eax
 00000408  E8 00000000 E		call SetTextColor		; reset text color to white on black
						
 0000040D  5A				pop edx                 ; pop the previous position from the stack into edx
 0000040E  58				pop eax                 ; pop the previous color from the stack into eax
 0000040F  C3				ret
 00000410			DrawPlayer ENDP

 00000410			UpdatePlayer PROC		    ; erase player the old position of the snake segment

 00000410  8A 96 000001B8 R		mov dl, xPos[esi]       ; puts the x position of the snake segment at index esi into dl
 00000416  8A B6 000003B1 R		mov dh,yPos[esi]        ; puts the y position of the snake segment at index esi into dh
 0000041C  E8 00000000 E		call Gotoxy             ; move cursor to (xPos, yPos)
 00000421  8A D0			mov dl, al			    ;temporarily save al in dl
 00000423  B0 20			mov al, " "             ; puts whitespace into al to erase the character
 00000425  E8 00000000 E		call WriteChar          ; writes whitespace at (xPos, yPos)
 0000042A  8A C2			mov al, dl              ; restores al from dl
 0000042C  C3				ret                     ; return from procedure
 0000042D			UpdatePlayer ENDP

 0000042D			DrawCoin PROC				;procedure to draw coin
 0000042D  B8 00000036			mov eax,brown + (cyan * 16) ; puts brown color value in eax because SetTextColor uses eax
 00000432  E8 00000000 E		call SetTextColor		;set color to brown with cyan background for coin
 00000437  8A 15 000005B2 R		mov dl,xCoinPos         ; puts the x position of the coin into dl
 0000043D  8A 35 000005B3 R		mov dh,yCoinPos         ; puts the y position of the coin into dh
 00000443  E8 00000000 E		call Gotoxy             ; move cursor to (xCoinPos, yCoinPos)
 00000448  B0 30			mov al, '0'             ; puts character '0' into al because WriteChar uses al
 0000044A  E8 00000000 E		call WriteChar          ; writes '0' at (xCoinPos, yCoinPos)
 0000044F  B8 0000000F			mov eax,white + (black * 16); puts white color value in eax because SetTextColor uses eax	
 00000454  E8 00000000 E		call SetTextColor       ;reset color to black and white 
 00000459  C3				ret
 0000045A			DrawCoin ENDP

 0000045A			CreateRandomCoin PROC
				    ; Compute interior bounds (exclusive of walls)
 0000045A  8A 15 000005AA R	    mov dl, xPosWall[0]    ; puts first element of xPosWall(10) into dl
 00000460  FE C2		    inc dl                 ; increment dl to get leftInner to avoid generating on wall
 00000462  8A 35 000005AC R	    mov dh, xPosWall[2]    ; puts third element of xPosWall(110) into dh
 00000468  FE CE		    dec dh                 ; decrement dh to get rightInner to avoid generating on wall
 0000046A  8A 1D 000005AE R	    mov bl, yPosWall[0]    ; puts first element of yPosWall(5) into bl
 00000470  FE C3		    inc bl                 ; increment bl to get topInner to avoid generating on wall
 00000472  8A 3D 000005AF R	    mov bh, yPosWall[1]    ; puts second element of yPosWall(25) into bh
 00000478  FE CF		    dec bh                 ; decrement bh to get bottomInner to avoid generating on wall


				    ; width  = rightInner - leftInner + 1  (store in ESI)
 0000047A  0F B6 F6		    movzx esi, dh          ;puts rightInner into esi to calculate width
 0000047D  0F B6 C2		    movzx eax, dl          ; puts leftInner into eax to calculate width
 00000480  2B F0		    sub esi, eax           ; subtract leftInner from rightInner
 00000482  46			    inc esi                ; increment esi so that width is inclusive

				    ; height = bottomInner - topInner + 1  (store in EDI)
 00000483  0F B6 FF		    movzx edi, bh          ; puts bottomInner into edi to calculate height
 00000486  0F B6 C3		    movzx eax, bl          ; puts topInner into eax to calculate height
 00000489  2B F8		    sub edi, eax           ; subtract topInner from bottomInner
 0000048B  47			    inc edi                ; increment edi so that height is inclusive

				    ; attempts = width * height (store in EBP)
 0000048C  8B C6		    mov eax, esi           ; puts esi(width) into eax so we can multiply
 0000048E  0F AF C7		    imul eax, edi          ; multiply eax(width) by edi(height) and store result in eax
 00000491  8B E8		    mov ebp, eax           ; puts eax(total unique cells within the walls) into ebp 
 00000493  8B CD		    mov ecx, ebp           ; puts ebp to ecx to use as attempts counter

 00000495			CR_try_random:
				    ; Random X
 00000495  52			    push edx               ; save boundaries
 00000496  53			    push ebx
 00000497  8B C6		    mov eax, esi           ; puts esi(width) into eax so we can get random in that range(RandomRange only accepts eax)
 00000499  E8 00000000 E	    call RandomRange       ; picks random number in range 0..width-1 and stores in EAX
 0000049E  5B			    pop ebx                ; restore boundaries
 0000049F  5A			    pop edx
 000004A0  02 C2		    add al, dl             ; adds leftInner so that random is within inner bounds
 000004A2  A2 000005B2 R	    mov xCoinPos, al       ; store result in xCoinPos

				    ; Random Y
 000004A7  52			    push edx
 000004A8  53			    push ebx
 000004A9  8B C7		    mov eax, edi           ; puts edi(height) into eax so we can get random in that range(RandomRange only accepts eax)
 000004AB  E8 00000000 E	    call RandomRange       ; picks random number in range 0..height-1 and stores in EAX
 000004B0  5B			    pop ebx
 000004B1  5A			    pop edx
 000004B2  02 C3		    add al, bl             ; adds topInner so that random is within inner bounds
 000004B4  A2 000005B3 R	    mov yCoinPos, al       ; store result in yCoinPos

				    ; Check snake overlap
 000004B9  BE 00000000		    mov esi, 0  ; initialize index to 0
 000004BE  8B 15 000001B4 R	    mov edx, snakeBodyInit ; initial segments
 000004C4  0F B7 05		    movzx eax, score
	   0000004F R
 000004CB  03 D0		    add edx, eax
 000004CD			CR_scan_snake:
 000004CD  8A 86 000001B8 R	    mov al, xPos[esi]
 000004D3  3A 05 000005B2 R	    cmp al, xCoinPos
 000004D9  75 0E		    jne CR_next_seg
 000004DB  8A 86 000003B1 R	    mov al, yPos[esi]
 000004E1  3A 05 000005B3 R	    cmp al, yCoinPos
 000004E7  74 55		    je CR_retry_random

 000004E9			CR_next_seg:
 000004E9  46			    inc esi
 000004EA  3B F2		    cmp esi, edx
 000004EC  7E DF		    jle CR_scan_snake

				    ; Check hazard overlap (ALL existing hazards)
 000004EE  0F B6 3D		    movzx edi, hazCount
	   000005CE R
 000004F5  85 FF		    test edi, edi
 000004F7  74 44		    jz CR_success
 000004F9  51			    push ecx                 ; preserve attempts counter
 000004FA  33 F6		    xor esi, esi             ; hazard index
 000004FC			CR_hz_loop:
 000004FC  32 C9		    xor cl, cl               ; cell index
 000004FE			CR_hz_cell_loop:
 000004FE  8A 86 000005CF R	    mov al, hazXs[esi]
 00000504  8A A6 000005D4 R	    mov ah, hazYs[esi]
 0000050A  8A 9E 000005D9 R	    mov bl, hazOrients[esi]
 00000510  80 FB 00		    cmp bl, 0
 00000513  75 04		    jne CR_hz_vert
 00000515  02 C1		    add al, cl               ; horiz cell
 00000517  EB 02		    jmp CR_hz_have
 00000519			CR_hz_vert:
 00000519  02 E1		    add ah, cl               ; vert cell
 0000051B			CR_hz_have:
 0000051B  3A 05 000005B2 R	    cmp al, xCoinPos
 00000521  75 08		    jne CR_hz_next_cell
 00000523  3A 25 000005B3 R	    cmp ah, yCoinPos
 00000529  74 0F		    je CR_hz_hit_all
 0000052B			CR_hz_next_cell:
 0000052B  FE C1		    inc cl
 0000052D  80 F9 0F		    cmp cl, HAZARD_LEN
 00000530  7C CC		    jl CR_hz_cell_loop
 00000532  46			    inc esi
 00000533  3B F7		    cmp esi, edi
 00000535  7C C5		    jl CR_hz_loop
 00000537  59			    pop ecx
 00000538  EB 03		    jmp CR_success

 0000053A			CR_hz_hit_all:
 0000053A  59			    pop ecx                  ; restore attempts before retry
 0000053B  EB 01		    jmp CR_retry_random

 0000053D			CR_success:
 0000053D  C3			    ret

 0000053E			CR_retry_random:
 0000053E  49			    dec ecx                 ; decrement attempts counter which has the total unique cells within the walls to avoid infinite loop
 0000053F  0F 85 FFFFFF50	    jnz CR_try_random       ; if not zero, jump back to try again

				    ; Fallback deterministic scan if total attempts counter is already 0
 00000545  8B CD		    mov ecx, ebp            ; gets the total unique cells within the walls again into ecx
 00000547  8A C2		    mov al, dl              ; puts dl which has a value of 10(leftInner) into al
 00000549  A2 000005B2 R	    mov xCoinPos, al        ; puts the value of al(10) into xCoinPos
 0000054E  8A C3		    mov al, bl              ; puts bl which has a value of 5(topInner) into al
 00000550  A2 000005B3 R	    mov yCoinPos, al        ; puts the value of al(5) into yCoinPos

 00000555			CR_scan_fallback:
				    ; Snake overlap check ; almost the same as CR_scan_snake
 00000555  BE 00000000		    mov esi, 0              ; puts 0 into esi to start checking from first segment
 0000055A  8B 15 000001B4 R	    mov edx, snakeBodyInit  ; puts 4 into edx for initial segments
 00000560  0F B7 05		    movzx eax, score        ; puts current score into eax
	   0000004F R
 00000567  03 D0		    add edx, eax            ; adds eax(score) to edx(total segments) to get total snake segments
 00000569			CR_fb_snake:
 00000569  8A 86 000001B8 R	    mov al, xPos[esi]       ; puts the first element of xPos into al(because esi is 0)
 0000056F  3A 05 000005B2 R	    cmp al, xCoinPos        ; compare coin x position with snake segment x position
 00000575  75 0E		    jne CR_fb_next_seg      ; jump if not same(not ovelapping each other), check next segment
 00000577  8A 86 000003B1 R	    mov al, yPos[esi]       ; puts y position of snake segment at index esi into al
 0000057D  3A 05 000005B3 R	    cmp al, yCoinPos        ; compare coin y position with snake segment y position
 00000583  74 49		    je CR_fb_advance        ; if equal, overlap detected, advance coin position

 00000585			CR_fb_next_seg: ; next segment
 00000585  46			    inc esi                 ; increment index to check next segment
 00000586  3B F2		    cmp esi, edx            ; compare esi now incremented by 1 with total segments
 00000588  7E DF		    jle CR_fb_snake         ; jump back to scan next segment if index <= total segments to check all snake segments

				    ; Hazard overlap check
 0000058A  80 3D 000005CA R	    cmp hazardActive, 0
	   00
 00000591  74 3A		    je CR_fb_done
 00000593  51			    push ecx                ; preserve scan counter
 00000594  32 C9		    xor cl, cl
 00000596			CR_fb_h_loop:
 00000596  A0 000005CC R	    mov al, hazardX
 0000059B  8A 25 000005CD R	    mov ah, hazardY
 000005A1  80 3D 000005CB R	    cmp hazardOrient, 0
	   00
 000005A8  75 04		    jne CR_fb_h_vert
 000005AA  02 C1		    add al, cl
 000005AC  EB 02		    jmp CR_fb_h_have
 000005AE			CR_fb_h_vert:
 000005AE  02 E1		    add ah, cl
 000005B0			CR_fb_h_have:
 000005B0  3A 05 000005B2 R	    cmp al, xCoinPos
 000005B6  75 08		    jne CR_fb_h_next
 000005B8  3A 25 000005B3 R	    cmp ah, yCoinPos
 000005BE  74 0A		    je CR_fb_h_hit
 000005C0			CR_fb_h_next:
 000005C0  FE C1		    inc cl
 000005C2  80 F9 0F		    cmp cl, HAZARD_LEN
 000005C5  72 CF		    jb CR_fb_h_loop
 000005C7  59			    pop ecx
 000005C8  EB 03		    jmp CR_fb_done

 000005CA			CR_fb_h_hit:
 000005CA  59			    pop ecx                ; restore scan counter before advancing
 000005CB  EB 01		    jmp CR_fb_advance

 000005CD			CR_fb_done:
 000005CD  C3			    ret

 000005CE			CR_fb_advance:
				    ; Advance to next cell (row-major)
 000005CE  A0 000005B2 R	    mov al, xCoinPos        ; puts current xCoinPos into al
 000005D3  FE C0		    inc al                  ; increment al to move the coin right
 000005D5  3A C6		    cmp al, dh              ; compare new al with dh which has a value of 110(rightInner)
 000005D7  76 1B		    jbe CR_set_x            ; jump to CR_set_x if dh is below or equal to new xCoinPos 
 000005D9  8A C2		    mov al, dl              ; puts dl which has a value of 10(leftInner) into al
 000005DB  A2 000005B2 R	    mov xCoinPos, al        ; puts the value of al(10) into xCoinPos
 000005E0  A0 000005B3 R	    mov al, yCoinPos        ; puts current yCoinPos into al
 000005E5  FE C0		    inc al                  ; increment al to move the coin down
 000005E7  3A C7		    cmp al, bh              ; compare new al with bh which has a value of 25(bottomInner)
 000005E9  76 02		    jbe CR_set_y            ; jump to CR_set_y if bh is below or equal to new yCoinPos
 000005EB  8A C3		    mov al, bl              ; puts bl which has a value of 5(topInner) into al
 000005ED			CR_set_y:
 000005ED  A2 000005B3 R	    mov yCoinPos, al        ; puts the value of al(5) into yCoinPos
 000005F2  EB 05		    jmp CR_after_adv        ; jump to CR_after_adv
 000005F4			CR_set_x:
 000005F4  A2 000005B2 R	    mov xCoinPos, al
 000005F9			CR_after_adv:               ; after advancing position
 000005F9  49			    dec ecx                 ; decrement scan counter which has the total unique cells within the walls
 000005FA  0F 85 FFFFFF55	    jnz CR_scan_fallback    ; if not zero, jump back to scan again
				    ; If all cells overlapped (board full), notify and end game
 00000600  E8 00000001		    CALL FinishedGame

 00000605  C3			    ret
 00000606			CreateRandomCoin ENDP


 00000606			FinishedGame PROC
 00000606  E8 00000000 E	    Call ClrScr

 0000060B  B2 32		    mov dl, 50
 0000060D  B6 0A		    mov dh, 10
 0000060F  E8 00000000 E	    call Gotoxy
 00000614  BA 000000F4 R	    mov edx, OFFSET strFinishedGame
 00000619  E8 00000000 E	    call WriteString

 0000061E  B2 32		    mov dl, 50
 00000620  B6 0C		    mov dh, 12
 00000622  E8 00000000 E	    call Gotoxy
 00000627  BA 0000011C R	    mov edx, OFFSET strNoMoreSpace
 0000062C  E8 00000000 E	    call WriteString

 00000631  B2 38		    mov dl,	56              ; centered at (56,14)
 00000633  B6 0E			mov dh, 14
 00000635  E8 00000000 E		call Gotoxy             ; Puts the cursor at (56,14)
 0000063A  66| A1			mov ax, score           ;gets the score and put it into ax
	   0000004F R
 00000640  E8 00000000 E		call WriteInt           ; Writes the integer score in position (56,14)
 00000645  BA 00000077 R		mov edx, OFFSET strPoints; puts the score in edx because WriteString uses edx
 0000064A  E8 00000000 E		call WriteString        ; Writes the string " point(s)"

 0000064F  B2 32			mov dl,	50              ; centered at (50,18)
 00000651  B6 12			mov dh, 18
 00000653  E8 00000000 E		call Gotoxy             ; Puts the cursor at (50,18)
 00000658  BA 00000051 R		mov edx, OFFSET strTryAgain ;puts the value of strTryAgain into edx because WriteString uses edx
 0000065D  E8 00000000 E		call WriteString		; Writes the string "Play again? (1 = Yes, 0 = No): "

 00000662				retry:
 00000662  B6 13			mov dh, 19              ;centered at (56,19)
 00000664  B2 38			mov dl,	56      
 00000666  E8 00000000 E		call Gotoxy             ; Puts the cursor at (56,19)
 0000066B  E8 00000000 E		call ReadInt			;get user input
 00000670  3C 01			cmp al, 1               ; compared the user input which is in al with 1
 00000672  0F 84 FFFFFC0D		je playagn		        ; if true (jump if equal), go to playagn
 00000678  3C 00			cmp al, 0               ;compared the user input which is in al with 0
 0000067A  0F 84 FFFFFC0A		je exitgame		        ; if true (jump if equal), go to exitgame

 00000680  B6 11			mov dh,	17              ; centered at (56,17)
 00000682  E8 00000000 E		call Gotoxy             ; Puts the cursor at (56,17)
 00000687  BA 00000069 R		mov edx, OFFSET invalidInput	; puts the value of invalidInput into edx because WriteString uses edx
 0000068C  E8 00000000 E		call WriteString		; Writes the string "Invalid input! Please enter 1 or 0."
 00000691  B2 38			mov dl,	56              ; centered at (56,19)
 00000693  B6 13			mov dh, 19     
 00000695  E8 00000000 E		call Gotoxy             ; Puts the cursor at (56,19)
 0000069A  BA 00000081 R		mov edx, OFFSET blank	;puts the value of blank into edx because WriteString uses edx
 0000069F  E8 00000000 E		call WriteString        ; Writes blank(which is just whitespaces) to erase previous input
 000006A4  EB BC			jmp retry			    ;let the user input again by jumping back to retry

 000006A6  C3			    ret
 000006A7			FinishedGame ENDP

 000006A7			CheckSnake PROC				;check whether the snake head collides w its body 
 000006A7  A0 000001B8 R		mov al, xPos[0]         ; puts the first element of xPos which is the snake's head into al
 000006AC  8A 25 000003B1 R		mov ah, yPos[0]         ; puts the first element of yPos which is the snake's head into ah
 000006B2  8B 35 000001B4 R		mov esi,snakeBodyInit	; puts 4 into esi to start checking from the 5th segment of the snake
 000006B8  B9 00000001			mov ecx,1               ; puts 1 into ecx to use as loop counter
 000006BD  0F B7 15			movzx edx, score        ; puts score into edx
	   0000004F R
 000006C4  03 CA			add ecx, edx            ; adds edx(score) to ecx to get total segments to check

 000006C6			checkXposition:
 000006C6  38 86 000001B8 R		cmp xPos[esi], al		;compares the xPos of the current segment(xPos[esi]) with the head's xPos(al)
 000006CC  74 0D			je XposSame             ; if same, jump to XposSame to check yPos
 000006CE				contloop:
 000006CE  46				inc esi                 ; increment index to check next segment
 000006CF  E2 F5		loop checkXposition
					
 000006D1  E8 00000646		    call CheckBlockCollision; Also check hazard block collision before returning to main    

 000006D6  E9 FFFFFB56			jmp checkcoin           ; reloop if no collision detected

 000006DB				XposSame:				; if xpos same, check for ypos
 000006DB  38 A6 000003B1 R		cmp yPos[esi], ah       ; compares the yPos of the current segment(yPos[esi]) with the head's yPos(ah)
 000006E1  0F 84 FFFFFB99		je diedBody					;if same, jump to died(calls YouDied PROC)
 000006E7  EB E5			jmp contloop            ; else, continue loop
 000006E9			CheckSnake ENDP


 000006E9			DrawBody PROC				; procedure to print body of the snake
 000006E9  8B 0D 000001B4 R		mov ecx, snakeBodyInit  ; initial snake body length
 000006EF  66| 03 0D			add cx, score		    ; add score to to snake body get total segments
	   0000004F R
 000006F6				printbodyloop:	
 000006F6  46				inc esi				    ; increment esi to point to next unit of the snake body
 000006F7  E8 FFFFFD14			call UpdatePlayer       ; erase previous position of the unit
 000006FC  8A 96 000001B8 R		mov dl, xPos[esi]       ; puts the new x position of the snake segment at index esi into dl
 00000702  8A B6 000003B1 R		mov dh, yPos[esi]	    ; puts the new y position of the snake segment at index esi into dh
 00000708  88 A6 000003B1 R		mov yPos[esi], ah       ; puts ah (which has the previous y position) into yPos[esi]
 0000070E  88 86 000001B8 R		mov xPos[esi], al	    ; puts al (which has the previous x position) into xPos[esi]
 00000714  8A C2			mov al, dl              ; puts dl (new x position) into al
 00000716  8A E6			mov ah,dh			    ; puts dh (new y position) into ah
 00000718  E8 FFFFFCBA			call DrawPlayer         ; draw the unit at new position
 0000071D  3B F1			cmp esi, ecx            ; compare esi with ecx(total segments)
 0000071F  7C D5			jl printbodyloop        ; if esi < ecx(total segments), jump back to printbodyloop
 00000721  C3				ret
 00000722			DrawBody ENDP




 00000722			EatingCoin PROC
					; snake is eating coin
 00000722  66| FF 05			inc score
	   0000004F R


 00000729  8B 1D 000001B4 R		mov ebx, snakeBodyInit  ; initial snake body length
 0000072F  0F B7 05			movzx eax, score        ; Load score into EAX (zero-extended)
	   0000004F R
 00000736  03 D8			add ebx, eax            ; add score to ebx to get new snake length
 00000738  8B F3			mov esi, ebx            ; put new snake length into esi for indexing
 0000073A  8A A6 000003B0 R		mov ah, yPos[esi-1]     ; put the yPos of the old tail into ah
 00000740  8A 86 000001B7 R		mov al, xPos[esi-1]	    ; put the xPos of the old tail into al
 00000746  88 86 000001B8 R		mov xPos[esi], al		; put pos of new tail into the pos of old tail
 0000074C  88 A6 000003B1 R		mov yPos[esi], ah		; put pos of new tail into the pos of old tail

 00000752  38 86 000001B6 R		cmp xPos[esi-2], al		; compare the old tail and the unit before so we know which direction to add the new tail
 00000758  75 1A			jne checky				; jump to checky if they are not on the same xAxis

 0000075A  38 A6 000003AF R		cmp yPos[esi-2], ah		; compare the old tail and the unit before so we know which direction to add the new tail
 00000760  7C 02			jl incy			        ; jump to incy if less than
 00000762  7F 08			jg decy                 ; jump to decy if greater than

 00000764				incy:					; inc if below
 00000764  FE 86 000003B1 R		inc yPos[esi]           ; increment yPos of new tail
 0000076A  EB 20			jmp continue            ; jump to continue

 0000076C				decy:					;dec if above
 0000076C  FE 8E 000003B1 R		dec yPos[esi]           ; decrement yPos of new tail
 00000772  EB 18			jmp continue

 00000774				checky:					; check yAxis
 00000774  38 A6 000003AF R		cmp yPos[esi-2], ah		; compare the old tail and the unit before so we know which direction to add the new tail
 0000077A  7C 02			jl incx                 ; jump to incx if less than
 0000077C  7F 08			jg decx                 ; jump to decx if greater than

 0000077E				incx:					; inc if right
 0000077E  FE 86 000001B8 R		inc xPos[esi]			; increment xPos of new tail
 00000784  EB 06			jmp continue            ; jump to continue

 00000786				decx:					; dec if left
 00000786  FE 8E 000001B8 R		dec xPos[esi]           ; decrement xPos of new tail

 0000078C				continue:				;add snake tail and update new coin
 0000078C  E8 FFFFFC46			call DrawPlayer		    ; draw new tail at (xPos,yPos)
 00000791  E8 FFFFFCC4			call CreateRandomCoin   ; create new coin
 00000796  E8 FFFFFC92			call DrawCoin           ; draw new coin at (xCoinPos,yCoinPos)
 0000079B  E8 FFFFFC0C			call UpdateSpeed        ; update speed based on score
 000007A0  E8 FFFFFB84			call DrawScoreboard     ; redraw scoreboard
 000007A5  E8 00000001		    call MaybeSpawnHazardBlock  ; spawn hazard every 5 points
					
 000007AA  C3				ret
 000007AB			EatingCoin ENDP


 000007AB			MaybeSpawnHazardBlock PROC
				    ; Trigger only on multiples of 5 (change ecx to 5 if you want that cadence)
 000007AB  0F B7 05		    movzx eax, score
	   0000004F R
 000007B2  B9 00000003		    mov ecx, 3
 000007B7  33 D2		    xor edx, edx
 000007B9  F7 F1		    div ecx
 000007BB  83 FA 00		    cmp edx, 0
 000007BE  0F 85 00000097	    jne MSP_done

				    ; Create candidate strictly between head and coin or randomized
 000007C4  E8 000003E3		    call CreateBetweenOrRandomHazardBlock
 000007C9  80 3D 000005CA R	    cmp hazardActive, 0
	   00
 000007D0  0F 84 00000085	    je MSP_done

				    ; If full, evict oldest and shift left
 000007D6  A0 000005CE R	    mov al, hazCount
 000007DB  3C 05		    cmp al, MAX_HAZARDS
 000007DD  72 3F		    jb MSP_space

 000007DF  B3 00		    mov bl, 0
 000007E1  E8 000004D8		    call ClearHazardAt

 000007E6  B9 00000004		    mov ecx, MAX_HAZARDS - 1
 000007EB  BE 00000000		    mov esi, 0
 000007F0			MSP_shift:
 000007F0  8A 86 000005D0 R	    mov al, hazXs[esi+1]
 000007F6  88 86 000005CF R	    mov hazXs[esi], al
 000007FC  8A 86 000005D5 R	    mov al, hazYs[esi+1]
 00000802  88 86 000005D4 R	    mov hazYs[esi], al
 00000808  8A 86 000005DA R	    mov al, hazOrients[esi+1]
 0000080E  88 86 000005D9 R	    mov hazOrients[esi], al
 00000814  46			    inc esi
 00000815  E2 D9		    loop MSP_shift
 00000817  C6 05 000005CE R	    mov hazCount, (MAX_HAZARDS - 1)
	   04

 0000081E			MSP_space:
				    ; Append candidate stored in hazardX/Y/Orient
 0000081E  0F B6 1D		    movzx ebx, hazCount
	   000005CE R
 00000825  A0 000005CC R	    mov al, hazardX
 0000082A  88 83 000005CF R	    mov hazXs[ebx], al
 00000830  A0 000005CD R	    mov al, hazardY
 00000835  88 83 000005D4 R	    mov hazYs[ebx], al
 0000083B  A0 000005CB R	    mov al, hazardOrient
 00000840  88 83 000005D9 R	    mov hazOrients[ebx], al

 00000846  A0 000005CE R	    mov al, hazCount
 0000084B  FE C0		    inc al
 0000084D  A2 000005CE R	    mov hazCount, al

 00000852  8A D8		    mov bl, al
 00000854  FE CB		    dec bl
 00000856  E8 000003F1		    call DrawHazardAt
 0000085B			MSP_done:
 0000085B  C3			    ret
 0000085C			MaybeSpawnHazardBlock ENDP


 0000085C			CreateMidpointHazardBlock PROC
 0000085C  C6 05 000005CA R	    mov hazardActive, 0
	   00

				    ; Head & coin positions
 00000863  0F B6 05		    movzx eax, xPos[0]        ; sx
	   000001B8 R
 0000086A  0F B6 1D		    movzx ebx, yPos[0]        ; sy
	   000003B1 R
 00000871  0F B6 0D		    movzx ecx, xCoinPos       ; cx
	   000005B2 R
 00000878  0F B6 15		    movzx edx, yCoinPos       ; cy
	   000005B3 R

				    ; dx, dy (signed in ESI/EDI)
 0000087F  8B F1		    mov esi, ecx
 00000881  2B F0		    sub esi, eax              ; dx
 00000883  8B FA		    mov edi, edx
 00000885  2B FB		    sub edi, ebx              ; dy

				    ; |dx| -> EAX
 00000887  8B C6		    mov eax, esi
 00000889  99			    cdq
 0000088A  33 C2		    xor eax, edx
 0000088C  2B C2		    sub eax, edx              ; EAX = |dx|

				    ; |dy| -> ECX
 0000088E  8B CF		    mov ecx, edi
 00000890  8B D1		    mov edx, ecx
 00000892  C1 FA 1F		    sar edx, 31
 00000895  33 CA		    xor ecx, edx
 00000897  2B CA		    sub ecx, edx              ; ECX = |dy|

				    ; Centers: ESI = centerX, EDI = centerY
 00000899  0F B6 35		    movzx esi, xPos[0]
	   000001B8 R
 000008A0  0F B6 15		    movzx edx, xCoinPos
	   000005B2 R
 000008A7  03 F2		    add esi, edx
 000008A9  D1 EE		    shr esi, 1

 000008AB  0F B6 3D		    movzx edi, yPos[0]
	   000003B1 R
 000008B2  0F B6 15		    movzx edx, yCoinPos
	   000005B3 R
 000008B9  03 FA		    add edi, edx
 000008BB  D1 EF		    shr edi, 1

				    ; Orientation: vertical if |dx| >= |dy|
 000008BD  3B C1		    cmp eax, ecx
 000008BF  7C 67		    jl HZ_mid_horiz

				    ; ---------------- Vertical ----------------
 000008C1  C6 05 000005CB R	    mov hazardOrient, 1
	   01

				    ; Interior bounds (32-bit)
 000008C8  0F B6 1D		    movzx ebx, xPosWall[0]
	   000005AA R
 000008CF  43			    inc ebx                    ; leftInner
 000008D0  0F B6 0D		    movzx ecx, xPosWall[2]
	   000005AC R
 000008D7  49			    dec ecx                    ; rightInner
 000008D8  0F B6 15		    movzx edx, yPosWall[0]
	   000005AE R
 000008DF  42			    inc edx                    ; topInner
 000008E0  0F B6 2D		    movzx ebp, yPosWall[1]
	   000005AF R
 000008E7  4D			    dec ebp                    ; bottomInner

				    ; startY = centerY - 7, clamp to [topInner .. bottomInner-(LEN-1)]
 000008E8  8B C7		    mov eax, edi               ; EAX = centerY
 000008EA  83 E8 07		    sub eax, ((HAZARD_LEN-1)/2)
 000008ED  8B DD		    mov ebx, ebp               ; EBX = bottomInner
 000008EF  83 EB 0E		    sub ebx, (HAZARD_LEN-1)    ; EBX = bottomStartMax
 000008F2  3B C2		    cmp eax, edx
 000008F4  7D 02		    jge V_low_ok
 000008F6  8B C2		    mov eax, edx
 000008F8			V_low_ok:
 000008F8  3B C3		    cmp eax, ebx
 000008FA  7E 02		    jle V_hi_ok
 000008FC  8B C3		    mov eax, ebx
 000008FE			V_hi_ok:
 000008FE  A2 000005CD R	    mov hazardY, al

				    ; hazardX = clamp(centerX, leftInner..rightInner)
 00000903  8B C6		    mov eax, esi
 00000905  0F B6 1D		    movzx ebx, xPosWall[0]
	   000005AA R
 0000090C  43			    inc ebx
 0000090D  0F B6 15		    movzx edx, xPosWall[2]
	   000005AC R
 00000914  4A			    dec edx
 00000915  3B C3		    cmp eax, ebx
 00000917  7D 02		    jge VX_low_ok
 00000919  8B C3		    mov eax, ebx
 0000091B			VX_low_ok:
 0000091B  3B C2		    cmp eax, edx
 0000091D  7E 02		    jle VX_hi_ok
 0000091F  8B C2		    mov eax, edx
 00000921			VX_hi_ok:
 00000921  A2 000005CC R	    mov hazardX, al
 00000926  EB 55		    jmp HZ_validate

				    ; ---------------- Horizontal ----------------
 00000928			HZ_mid_horiz:
 00000928  C6 05 000005CB R	    mov hazardOrient, 0
	   00

				    ; Interior bounds (32-bit)
 0000092F  0F B6 1D		    movzx ebx, xPosWall[0]
	   000005AA R
 00000936  43			    inc ebx                    ; leftInner
 00000937  0F B6 0D		    movzx ecx, xPosWall[2]
	   000005AC R
 0000093E  49			    dec ecx                    ; rightInner
 0000093F  0F B6 15		    movzx edx, yPosWall[0]
	   000005AE R
 00000946  42			    inc edx                    ; topInner
 00000947  0F B6 2D		    movzx ebp, yPosWall[1]
	   000005AF R
 0000094E  4D			    dec ebp                    ; bottomInner

				    ; startX = centerX - 7, clamp to [leftInner .. rightInner-(LEN-1)]
 0000094F  8B C6		    mov eax, esi               ; EAX = centerX
 00000951  83 E8 07		    sub eax, ((HAZARD_LEN-1)/2)
 00000954  8B C9		    mov ecx, ecx               ; ECX = rightInner (already)
 00000956  83 E9 0E		    sub ecx, (HAZARD_LEN-1)    ; ECX = rightStartMax
 00000959  3B C3		    cmp eax, ebx
 0000095B  7D 02		    jge H_low_ok
 0000095D  8B C3		    mov eax, ebx
 0000095F			H_low_ok:
 0000095F  3B C1		    cmp eax, ecx
 00000961  7E 02		    jle H_hi_ok
 00000963  8B C1		    mov eax, ecx
 00000965			H_hi_ok:
 00000965  A2 000005CC R	    mov hazardX, al

				    ; hazardY = clamp(centerY, topInner..bottomInner)
 0000096A  8B C7		    mov eax, edi
 0000096C  3B C2		    cmp eax, edx
 0000096E  7D 02		    jge HY_low_ok
 00000970  8B C2		    mov eax, edx
 00000972			HY_low_ok:
 00000972  3B C5		    cmp eax, ebp
 00000974  7E 02		    jle HY_hi_ok
 00000976  8B C5		    mov eax, ebp
 00000978			HY_hi_ok:
 00000978  A2 000005CD R	    mov hazardY, al

				    ; ---------------- Validate cells ----------------
 0000097D			HZ_validate:
 0000097D  33 C9		    xor ecx, ecx               ; i = 0..HAZARD_LEN-1
 0000097F			HZ_cell_loop3:
 0000097F  A0 000005CC R	    mov al, hazardX
 00000984  8A 25 000005CD R	    mov ah, hazardY
 0000098A  80 3D 000005CB R	    cmp hazardOrient, 0
	   00
 00000991  75 04		    jne HZ_cell_v3
 00000993  02 C1		    add al, cl                 ; horizontal
 00000995  EB 02		    jmp HZ_cell_have3
 00000997			HZ_cell_v3:
 00000997  02 E1		    add ah, cl                 ; vertical
 00000999			HZ_cell_have3:
				    ; Bounds check using 32-bit compares
 00000999  0F B6 C0		    movzx eax, al
 0000099C  0F B6 15		    movzx edx, xPosWall[0]
	   000005AA R
 000009A3  42			    inc edx
 000009A4  3B C2		    cmp eax, edx
 000009A6  72 7A		    jb HZ_fail2
 000009A8  0F B6 15		    movzx edx, xPosWall[2]
	   000005AC R
 000009AF  4A			    dec edx
 000009B0  3B C2		    cmp eax, edx
 000009B2  77 6E		    ja HZ_fail2

 000009B4  0F B6 C4		    movzx eax, ah
 000009B7  0F B6 15		    movzx edx, yPosWall[0]
	   000005AE R
 000009BE  42			    inc edx
 000009BF  3B C2		    cmp eax, edx
 000009C1  72 5F		    jb HZ_fail2
 000009C3  0F B6 15		    movzx edx, yPosWall[1]
	   000005AF R
 000009CA  4A			    dec edx
 000009CB  3B C2		    cmp eax, edx
 000009CD  77 53		    ja HZ_fail2

				    ; Snake overlap?
 000009CF  BE 00000000		    mov esi, 0
 000009D4  8B 15 000001B4 R	    mov edx, snakeBodyInit          ; initial segments
 000009DA  0F B7 2D		    movzx ebp, score
	   0000004F R
 000009E1  03 D5		    add edx, ebp
 000009E3			HZ_snake_scan3:
 000009E3  8A 9E 000001B8 R	    mov bl, xPos[esi]
 000009E9  3A D8		    cmp bl, al                      ; al contains current hazard cell X
 000009EB  75 0A		    jne HZ_next_seg3
 000009ED  8A 9E 000003B1 R	    mov bl, yPos[esi]
 000009F3  3A DC		    cmp bl, ah                      ; ah contains current hazard cell Y
 000009F5  74 2B		    je HZ_fail2                     ; if overlap detected, fail this hazard
 000009F7			HZ_next_seg3:
 000009F7  46			    inc esi
 000009F8  3B F2		    cmp esi, edx
 000009FA  7E E7		    jle HZ_snake_scan3

				    ; Coin overlap?
 000009FC  8A 1D 000005B2 R	    mov bl, xCoinPos
 00000A02  3A D8		    cmp bl, al
 00000A04  75 0A		    jne HZ_coin_ok3
 00000A06  8A 1D 000005B3 R	    mov bl, yCoinPos
 00000A0C  3A DC		    cmp bl, ah
 00000A0E  74 12		    je HZ_fail2
 00000A10			HZ_coin_ok3:
 00000A10  41			    inc ecx
 00000A11  83 F9 0F		    cmp ecx, HAZARD_LEN
 00000A14  0F 8C FFFFFF65	    jl HZ_cell_loop3

 00000A1A  C6 05 000005CA R	    mov hazardActive, 1
	   01
 00000A21  C3			    ret

 00000A22			HZ_fail2:
 00000A22  C6 05 000005CA R	    mov hazardActive, 0
	   00
 00000A29  C3			    ret
 00000A2A			CreateMidpointHazardBlock ENDP


 00000A2A			CreateRandomHazardBlock PROC
				    ; Tries up to 64 random placements
 00000A2A  C6 05 000005CA R	    mov hazardActive, 0
	   00

 00000A31  B9 00000040		    mov ecx, 64          ; attempt counter

 00000A36			CRH_try:
				    ; Interior bounds (use 8-bit regs as before)
 00000A36  A0 000005AA R	    mov al, xPosWall[0]
 00000A3B  FE C0		    inc al                ; leftInner
 00000A3D  8A 1D 000005AC R	    mov bl, xPosWall[2]
 00000A43  FE CB		    dec bl                ; rightInner
 00000A45  8A 25 000005AE R	    mov ah, yPosWall[0]
 00000A4B  FE C4		    inc ah                ; topInner
 00000A4D  8A 3D 000005AF R	    mov bh, yPosWall[1]
 00000A53  FE CF		    dec bh                ; bottomInner

				    ; Random orientation (0 = horiz, 1 = vert)
 00000A55  B8 00000002		    mov eax, 2
 00000A5A  E8 00000000 E	    call RandomRange
 00000A5F  A2 000005CB R	    mov hazardOrient, al

				    ; Choose base (hazardX/hazardY) so the 10 cells fit
 00000A64  80 3D 000005CB R	    cmp hazardOrient, 0
	   00
 00000A6B  75 3F		    jne CRH_vert

				    ; Horizontal: x in [leftInner .. rightInner-(HAZARD_LEN-1)]
 00000A6D  0F B6 D3		    movzx edx, bl
 00000A70  0F B6 C0		    movzx eax, al         ; leftInner in AL -> zero-extend
 00000A73  2B D0		    sub edx, eax
 00000A75  83 EA 0E		    sub edx, (HAZARD_LEN-1)
 00000A78  42			    inc edx               ; range width
 00000A79  8B C2		    mov eax, edx
 00000A7B  E8 00000000 E	    call RandomRange
 00000A80  02 05 000005AA R	    add al, xPosWall[0]
 00000A86  FE C0		    inc al
 00000A88  A2 000005CC R	    mov hazardX, al

				    ; Y any interior row
 00000A8D  0F B6 D7		    movzx edx, bh
 00000A90  0F B6 C4		    movzx eax, ah
 00000A93  2B D0		    sub edx, eax
 00000A95  42			    inc edx
 00000A96  8B C2		    mov eax, edx
 00000A98  E8 00000000 E	    call RandomRange
 00000A9D  02 05 000005AE R	    add al, yPosWall[0]
 00000AA3  FE C0		    inc al
 00000AA5  A2 000005CD R	    mov hazardY, al
 00000AAA  EB 42		    jmp CRH_validate

 00000AAC			CRH_vert:
				    ; Vertical: y in [topInner .. bottomInner-(HAZARD_LEN-1)]
 00000AAC  0F B6 D7		    movzx edx, bh
 00000AAF  0F B6 C4		    movzx eax, ah
 00000AB2  2B D0		    sub edx, eax
 00000AB4  83 EA 0E		    sub edx, (HAZARD_LEN-1)
 00000AB7  42			    inc edx
 00000AB8  8B C2		    mov eax, edx
 00000ABA  E8 00000000 E	    call RandomRange
 00000ABF  02 05 000005AE R	    add al, yPosWall[0]
 00000AC5  FE C0		    inc al
 00000AC7  A2 000005CD R	    mov hazardY, al

				    ; X any interior column
 00000ACC  0F B6 D3		    movzx edx, bl
 00000ACF  0F B6 05		    movzx eax, xPosWall[0]
	   000005AA R
 00000AD6  40			    inc eax
 00000AD7  2B D0		    sub edx, eax
 00000AD9  42			    inc edx
 00000ADA  8B C2		    mov eax, edx
 00000ADC  E8 00000000 E	    call RandomRange
 00000AE1  02 05 000005AA R	    add al, xPosWall[0]
 00000AE7  FE C0		    inc al
 00000AE9  A2 000005CC R	    mov hazardX, al

 00000AEE			CRH_validate:
 00000AEE  33 D2		    xor edx, edx          ; i=0..HAZARD_LEN-1 in DL
 00000AF0			CRH_loop_cells:
 00000AF0  A0 000005CC R	    mov al, hazardX
 00000AF5  8A 25 000005CD R	    mov ah, hazardY
 00000AFB  80 3D 000005CB R	    cmp hazardOrient, 0
	   00
 00000B02  75 04		    jne CRH_v_add
 00000B04  02 C2		    add al, dl
 00000B06  EB 02		    jmp CRH_have
 00000B08			CRH_v_add:
 00000B08  02 E2		    add ah, dl
 00000B0A			CRH_have:
				    ; Bounds (already ensured by construction, but keep safety)
 00000B0A  8A 1D 000005AA R	    mov bl, xPosWall[0]
 00000B10  FE C3		    inc bl
 00000B12  3A C3		    cmp al, bl
 00000B14  0F 82 00000083	    jb CRH_fail_attempt
 00000B1A  8A 1D 000005AC R	    mov bl, xPosWall[2]
 00000B20  FE CB		    dec bl
 00000B22  3A C3		    cmp al, bl
 00000B24  77 77		    ja CRH_fail_attempt

 00000B26  8A 1D 000005AE R	    mov bl, yPosWall[0]
 00000B2C  FE C3		    inc bl
 00000B2E  3A E3		    cmp ah, bl
 00000B30  72 6B		    jb CRH_fail_attempt
 00000B32  8A 1D 000005AF R	    mov bl, yPosWall[1]
 00000B38  FE CB		    dec bl
 00000B3A  3A E3		    cmp ah, bl
 00000B3C  77 5F		    ja CRH_fail_attempt

				    ; Snake overlap? (per hazard cell, check all segments; avoid EBX corruption)
 00000B3E  52			    push edx                  ; save DL (cell index)
 00000B3F  50			    push eax                  ; save AL/AH (cell coords)
 00000B40  BE 00000000		    mov esi, 0
 00000B45  8B 3D 000001B4 R	    mov edi, snakeBodyInit
 00000B4B  0F B7 05		    movzx eax, score
	   0000004F R
 00000B52  03 F8		    add edi, eax              ; edi = total segments
 00000B54  58			    pop eax                   ; restore AL/AH (cell coords)
 00000B55			CRH_snake_scan_cell:
 00000B55  53			    push ebx                  ; we'll use BL for comparisons
 00000B56  8A 9E 000001B8 R	    mov bl, xPos[esi]
 00000B5C  3A D8		    cmp bl, al
 00000B5E  75 0F		    jne CRH_snake_next_cell
 00000B60  8A 9E 000003B1 R	    mov bl, yPos[esi]
 00000B66  3A DC		    cmp bl, ah
 00000B68  5B			    pop ebx
 00000B69  5A			    pop edx                   ; restore DL before failing
 00000B6A  74 31		    je CRH_fail_attempt       ; overlap with this cell
 00000B6C  52			    push edx
 00000B6D  EB 01		    jmp CRH_snake_cont_cell
 00000B6F			CRH_snake_next_cell:
 00000B6F  5B			    pop ebx
 00000B70			CRH_snake_cont_cell:
 00000B70  46			    inc esi
 00000B71  3B F7		    cmp esi, edi
 00000B73  7C E0		    jl CRH_snake_scan_cell
 00000B75  5A			    pop edx                   ; restore DL

				    ; Coin overlap?
 00000B76  8A 1D 000005B2 R	    mov bl, xCoinPos
 00000B7C  3A D8		    cmp bl, al
 00000B7E  75 0A		    jne CRH_coin_ok
 00000B80  8A 1D 000005B3 R	    mov bl, yCoinPos
 00000B86  3A DC		    cmp bl, ah
 00000B88  74 13		    je CRH_fail_attempt
 00000B8A			CRH_coin_ok:
 00000B8A  FE C2		    inc dl
 00000B8C  80 FA 0F		    cmp dl, HAZARD_LEN
 00000B8F  0F 82 FFFFFF5B	    jb CRH_loop_cells

 00000B95  C6 05 000005CA R	    mov hazardActive, 1
	   01
 00000B9C  C3			    ret

 00000B9D			CRH_fail_attempt:
 00000B9D  49			    dec ecx
 00000B9E  0F 85 FFFFFE92	    jnz CRH_try
 00000BA4  C6 05 000005CA R	    mov hazardActive, 0
	   00
 00000BAB  C3			    ret
 00000BAC			CreateRandomHazardBlock ENDP



 00000BAC			CreateBetweenOrRandomHazardBlock PROC
				    ; Compute Manhattan distance between head and coin: |dx| + |dy|
 00000BAC  0F B6 05		    movzx eax, xPos[0]        ; sx
	   000001B8 R
 00000BB3  0F B6 1D		    movzx ebx, yPos[0]        ; sy
	   000003B1 R
 00000BBA  0F B6 0D		    movzx ecx, xCoinPos       ; cx
	   000005B2 R
 00000BC1  0F B6 15		    movzx edx, yCoinPos       ; cy
	   000005B3 R

 00000BC8  8B F1		    mov esi, ecx
 00000BCA  2B F0		    sub esi, eax              ; dx = cx - sx
 00000BCC  8B FA		    mov edi, edx
 00000BCE  2B FB		    sub edi, ebx              ; dy = cy - sy

				    ; |dx| -> EAX
 00000BD0  8B C6		    mov eax, esi
 00000BD2  99			    cdq
 00000BD3  33 C2		    xor eax, edx
 00000BD5  2B C2		    sub eax, edx

				    ; |dy| -> ECX
 00000BD7  8B CF		    mov ecx, edi
 00000BD9  8B D1		    mov edx, ecx
 00000BDB  C1 FA 1F		    sar edx, 31
 00000BDE  33 CA		    xor ecx, edx
 00000BE0  2B CA		    sub ecx, edx

 00000BE2  03 C1		    add eax, ecx              ; manhattan = |dx| + |dy|
 00000BE4  83 F8 06		    cmp eax, HAZARD_CLOSE_DIST
 00000BE7  76 5D		    jbe CBR_random            ; too close -> randomize

				    ; Try strict midpoint barrier (already validates bounds/snake/coin)
 00000BE9  E8 FFFFFC6E		    call CreateMidpointHazardBlock
 00000BEE  80 3D 000005CA R	    cmp hazardActive, 0
	   00
 00000BF5  74 4F		    je CBR_random

				    ; Ensure barrier lies strictly between head and coin along the perpendicular axis.
				    ; If vertical barrier, its X must be between head.x and coin.x.
				    ; If horizontal barrier, its Y must be between head.y and coin.y.
 00000BF7  A0 000005CB R	    mov al, hazardOrient
 00000BFC  3C 00		    cmp al, 0
 00000BFE  75 23		    jne CBR_vert_check

				    ; Horizontal barrier -> check hazardY between min(sy,cy) .. max(sy,cy)
 00000C00  A0 000003B1 R	    mov al, yPos[0]
 00000C05  8A 25 000005B3 R	    mov ah, yCoinPos
 00000C0B  8A D8		    mov bl, al
 00000C0D  8A FC		    mov bh, ah
 00000C0F  3A DF		    cmp bl, bh
 00000C11  76 02		    jbe CBR_h_haveBounds
 00000C13  86 DF		    xchg bl, bh
 00000C15			CBR_h_haveBounds:
 00000C15  A0 000005CD R	    mov al, hazardY
 00000C1A  3A C3		    cmp al, bl
 00000C1C  72 28		    jb CBR_random            ; outside between slab -> randomize
 00000C1E  3A C7		    cmp al, bh
 00000C20  77 24		    ja CBR_random
 00000C22  C3			    ret

 00000C23			CBR_vert_check:
				    ; Vertical barrier -> check hazardX between min(sx,cx) .. max(sx,cy)
 00000C23  A0 000001B8 R	    mov al, xPos[0]
 00000C28  8A 25 000005B2 R	    mov ah, xCoinPos
 00000C2E  8A D8		    mov bl, al
 00000C30  8A FC		    mov bh, ah
 00000C32  3A DF		    cmp bl, bh
 00000C34  76 02		    jbe CBR_v_haveBounds
 00000C36  86 DF		    xchg bl, bh
 00000C38			CBR_v_haveBounds:
 00000C38  A0 000005CC R	    mov al, hazardX
 00000C3D  3A C3		    cmp al, bl
 00000C3F  72 05		    jb CBR_random
 00000C41  3A C7		    cmp al, bh
 00000C43  77 01		    ja CBR_random
 00000C45  C3			    ret

 00000C46			CBR_random:
				    ; Fallback: random orientation/position fully inside bounds
 00000C46  E8 FFFFFDDF		    call CreateRandomHazardBlock
 00000C4B  C3			    ret
 00000C4C			CreateBetweenOrRandomHazardBlock ENDP


				; Draw one hazard from arrays at index BL
 00000C4C			DrawHazardAt PROC
 00000C4C  50			    push eax
 00000C4D  53			    push ebx
 00000C4E  51			    push ecx
 00000C4F  52			    push edx

 00000C50  B8 00000040		    mov eax, black + (red * 16)
 00000C55  E8 00000000 E	    call SetTextColor

 00000C5A  0F B6 DB		    movzx ebx, bl
 00000C5D  33 C9		    xor ecx, ecx              ; i = 0..HAZARD_LEN-1
 00000C5F			DHA_loop:
				    ; base
 00000C5F  8A 93 000005CF R	    mov dl, hazXs[ebx]
 00000C65  8A B3 000005D4 R	    mov dh, hazYs[ebx]
 00000C6B  8A 83 000005D9 R	    mov al, hazOrients[ebx]
 00000C71  3C 00		    cmp al, 0
 00000C73  75 04		    jne DHA_v
 00000C75  02 D1		    add dl, cl                ; horizontal
 00000C77  EB 02		    jmp DHA_have
 00000C79			DHA_v:
 00000C79  02 F1		    add dh, cl                ; vertical
 00000C7B			DHA_have:
				    ; never draw over walls
 00000C7B  3A 15 000005AA R	    cmp dl, xPosWall[0]
 00000C81  74 26		    je DHA_skip
 00000C83  3A 15 000005AC R	    cmp dl, xPosWall[2]
 00000C89  74 1E		    je DHA_skip
 00000C8B  3A 35 000005AE R	    cmp dh, yPosWall[0]
 00000C91  74 16		    je DHA_skip
 00000C93  3A 35 000005AF R	    cmp dh, yPosWall[1]
 00000C99  74 0E		    je DHA_skip

 00000C9B  51			    push ecx
 00000C9C  E8 00000000 E	    call Gotoxy
 00000CA1  B0 23		    mov al, '#'
 00000CA3  E8 00000000 E	    call WriteChar
 00000CA8  59			    pop ecx

 00000CA9			DHA_skip:
 00000CA9  41			    inc ecx
 00000CAA  83 F9 0F		    cmp ecx, HAZARD_LEN
 00000CAD  7C B0		    jl DHA_loop

 00000CAF  B8 0000000F		    mov eax, white + (black * 16)
 00000CB4  E8 00000000 E	    call SetTextColor

 00000CB9  5A			    pop edx
 00000CBA  59			    pop ecx
 00000CBB  5B			    pop ebx
 00000CBC  58			    pop eax
 00000CBD  C3			    ret
 00000CBE			DrawHazardAt ENDP


				; Clear one hazard from arrays at index BL
 00000CBE			ClearHazardAt PROC
 00000CBE  50			    push eax
 00000CBF  53			    push ebx
 00000CC0  51			    push ecx
 00000CC1  52			    push edx

 00000CC2  0F B6 DB		    movzx ebx, bl
 00000CC5  33 C9		    xor ecx, ecx              ; i = 0..HAZARD_LEN-1
 00000CC7			CHA_loop:
				    ; base
 00000CC7  8A 93 000005CF R	    mov dl, hazXs[ebx]
 00000CCD  8A B3 000005D4 R	    mov dh, hazYs[ebx]
 00000CD3  8A 83 000005D9 R	    mov al, hazOrients[ebx]
 00000CD9  3C 00		    cmp al, 0
 00000CDB  75 04		    jne CHA_v
 00000CDD  02 D1		    add dl, cl                ; horizontal
 00000CDF  EB 02		    jmp CHA_have
 00000CE1			CHA_v:
 00000CE1  02 F1		    add dh, cl                ; vertical
 00000CE3			CHA_have:
				    ; never erase wall cells
 00000CE3  3A 15 000005AA R	    cmp dl, xPosWall[0]
 00000CE9  74 26		    je CHA_skip
 00000CEB  3A 15 000005AC R	    cmp dl, xPosWall[2]
 00000CF1  74 1E		    je CHA_skip
 00000CF3  3A 35 000005AE R	    cmp dh, yPosWall[0]
 00000CF9  74 16		    je CHA_skip
 00000CFB  3A 35 000005AF R	    cmp dh, yPosWall[1]
 00000D01  74 0E		    je CHA_skip

 00000D03  51			    push ecx
 00000D04  E8 00000000 E	    call Gotoxy
 00000D09  B0 20		    mov al, ' '
 00000D0B  E8 00000000 E	    call WriteChar
 00000D10  59			    pop ecx

 00000D11			CHA_skip:
 00000D11  41			    inc ecx
 00000D12  83 F9 0F		    cmp ecx, HAZARD_LEN
 00000D15  7C B0		    jl CHA_loop

 00000D17  5A			    pop edx
 00000D18  59			    pop ecx
 00000D19  5B			    pop ebx
 00000D1A  58			    pop eax
 00000D1B  C3			    ret
 00000D1C			ClearHazardAt ENDP



 00000D1C			CheckBlockCollision PROC        ; Die if snake head is on any cell of any active hazard.  
 00000D1C  0F B6 3D		    movzx edi, hazCount         ; puts hazCount into edi
	   000005CE R
 00000D23  85 FF		    test edi, edi               ; to check if there is 0 hazards
 00000D25  74 45		    jz CBC_done                 ; if hazard count is 0, jump to CBC_done

 00000D27  8A 15 000001B8 R	    mov dl, xPos[0]             ; puts snake head X into dl
 00000D2D  8A 35 000003B1 R	    mov dh, yPos[0]             ; puts snake head Y into dh

 00000D33  33 F6		    xor esi, esi                ; makes esi = 0 to use as hazard index. Hazard index is used to iterate through each hazard
 00000D35			CBC_h_loop:
 00000D35  33 C9		    xor ecx, ecx                ; makes ecx = 0 to use as cell index. Cell index is used to iterate through each cell of the hazard

 00000D37			CBC_c_loop:
				    ; load base of current hazard
 00000D37  8A 86 000005CF R	    mov al, hazXs[esi]          ; puts hazard's first x element into al
 00000D3D  8A A6 000005D4 R	    mov ah, hazYs[esi]          ; puts hazard's first y element into ah
 00000D43  8A 9E 000005D9 R	    mov bl, hazOrients[esi]     ; puts hazard's orientation into bl(1 for vertical, 0 for horizontal)
 00000D49  80 FB 00		    cmp bl, 0                   ; compares orientation with 0(which is horizontal)
 00000D4C  75 04		    jne CBC_vert                ; if not equal, jump to CBC_vert
 00000D4E  02 C1		    add al, cl                  ; add cl to al and store in al so that al = baseX + i
 00000D50  EB 02		    jmp CBC_have                ; jump to CBC_have
 00000D52			CBC_vert:
 00000D52  02 E1		    add ah, cl                  ; add cl to ah and store in ah so that ah = baseY + i
 00000D54			CBC_have:
				    ; compare with head (dl,dh)
 00000D54  3A D0		    cmp dl, al                  ; compare headX with cellX
 00000D56  75 09		    jne CBC_next_cell           ; if not equal, jump to next cell
 00000D58  3A F4		    cmp dh, ah                  ; else, compare headY with cellY
 00000D5A  75 05		    jne CBC_next_cell           ; if not equal, jump to next cell
 00000D5C  E8 0000000C		    call YouDiedHazard          ; else, if equal, collision, dead

 00000D61			CBC_next_cell:
 00000D61  41			    inc ecx                     ; increment cell index
 00000D62  83 F9 0F		    cmp ecx, HAZARD_LEN         ; compare cell index with HAZARD_LEN(15)
 00000D65  7C D0		    jl CBC_c_loop               ; if cell index < HAZARD_LEN, jump back to CBC_c_loop. This loops through all cells of the hazard

 00000D67  46			    inc esi                     ; increment hazard index
 00000D68  3B F7		    cmp esi, edi                ; compare hazard index with hazCount
 00000D6A  7C C9		    jl CBC_h_loop               ; if hazard index < hazCount, jump back to CBC_h_loop. This loops through all hazards

 00000D6C			CBC_done:
 00000D6C  C3			    ret
 00000D6D			CheckBlockCollision ENDP


 00000D6D			YouDiedHazard PROC
 00000D6D  B8 000003E8			mov eax, 1000
 00000D72  E8 00000000 E		call delay
 00000D77  E8 00000000 E		Call ClrScr
					
 00000D7C  B2 32		    mov dl, 50
 00000D7E  B6 0C			mov dh, 12
 00000D80  E8 00000000 E		call Gotoxy
 00000D85  BA 000000DA R		mov edx, OFFSET strCollision
 00000D8A  E8 00000000 E		call WriteString

 00000D8F  B2 38			mov dl, 56
 00000D91  B6 0E			mov dh, 14
 00000D93  E8 00000000 E		call Gotoxy
 00000D98  66| A1			mov ax, score
	   0000004F R
 00000D9E  E8 00000000 E		call WriteInt
 00000DA3  BA 00000077 R		mov edx, OFFSET strPoints
 00000DA8  E8 00000000 E		call WriteString

 00000DAD  B2 32			mov dl, 50
 00000DAF  B6 12			mov dh, 18
 00000DB1  E8 00000000 E		call Gotoxy
 00000DB6  BA 00000051 R		mov edx, OFFSET strTryAgain
 00000DBB  E8 00000000 E		call WriteString

 00000DC0				retryHaz:
 00000DC0  B6 13			mov dh, 19
 00000DC2  B2 38			mov dl, 56
 00000DC4  E8 00000000 E		call Gotoxy
 00000DC9  E8 00000000 E		call ReadInt
 00000DCE  3C 01			cmp al, 1
 00000DD0  0F 84 FFFFF4AF		je playagn
 00000DD6  3C 00			cmp al, 0
 00000DD8  0F 84 FFFFF4AC		je exitgame

 00000DDE  B6 11			mov dh, 17
 00000DE0  E8 00000000 E		call Gotoxy
 00000DE5  BA 00000069 R		mov edx, OFFSET invalidInput
 00000DEA  E8 00000000 E		call WriteString
 00000DEF  B2 38			mov dl, 56
 00000DF1  B6 13			mov dh, 19
 00000DF3  E8 00000000 E		call Gotoxy
 00000DF8  BA 00000081 R		mov edx, OFFSET blank
 00000DFD  E8 00000000 E		call WriteString
 00000E02  EB BC			jmp retryHaz
 00000E04			YouDiedHazard ENDP

 00000E04			YouDiedWall PROC
 00000E04  B8 000003E8			mov eax, 1000
 00000E09  E8 00000000 E		call delay
 00000E0E  E8 00000000 E		Call ClrScr
					
 00000E13  B2 35		    mov dl, 53
 00000E15  B6 0C			mov dh, 12
 00000E17  E8 00000000 E		call Gotoxy
 00000E1C  BA 000000B1 R		mov edx, OFFSET strWallDeath
 00000E21  E8 00000000 E		call WriteString

 00000E26  B2 38			mov dl, 56
 00000E28  B6 0E			mov dh, 14
 00000E2A  E8 00000000 E		call Gotoxy
 00000E2F  66| A1			mov ax, score
	   0000004F R
 00000E35  E8 00000000 E		call WriteInt
 00000E3A  BA 00000077 R		mov edx, OFFSET strPoints
 00000E3F  E8 00000000 E		call WriteString

 00000E44  B2 32			mov dl, 50
 00000E46  B6 12			mov dh, 18
 00000E48  E8 00000000 E		call Gotoxy
 00000E4D  BA 00000051 R		mov edx, OFFSET strTryAgain
 00000E52  E8 00000000 E		call WriteString

 00000E57				retryWall:
 00000E57  B6 13			mov dh, 19
 00000E59  B2 38			mov dl, 56
 00000E5B  E8 00000000 E		call Gotoxy
 00000E60  E8 00000000 E		call ReadInt
 00000E65  3C 01			cmp al, 1
 00000E67  0F 84 FFFFF418		je playagn
 00000E6D  3C 00			cmp al, 0
 00000E6F  0F 84 FFFFF415		je exitgame

 00000E75  B6 11			mov dh, 17
 00000E77  E8 00000000 E		call Gotoxy
 00000E7C  BA 00000069 R		mov edx, OFFSET invalidInput
 00000E81  E8 00000000 E		call WriteString
 00000E86  B2 38			mov dl, 56
 00000E88  B6 13			mov dh, 19
 00000E8A  E8 00000000 E		call Gotoxy
 00000E8F  BA 00000081 R		mov edx, OFFSET blank
 00000E94  E8 00000000 E		call WriteString
 00000E99  EB BC			jmp retryWall
 00000E9B			YouDiedWall ENDP

 00000E9B			YouDiedBody PROC
 00000E9B  B8 000003E8			mov eax, 1000
 00000EA0  E8 00000000 E		call delay
 00000EA5  E8 00000000 E		Call ClrScr
					
 00000EAA  B2 34		    mov dl, 52
 00000EAC  B6 0C			mov dh, 12
 00000EAE  E8 00000000 E		call Gotoxy
 00000EB3  BA 000000C3 R		mov edx, OFFSET strBodyDeath
 00000EB8  E8 00000000 E		call WriteString

 00000EBD  B2 38			mov dl, 56
 00000EBF  B6 0E			mov dh, 14
 00000EC1  E8 00000000 E		call Gotoxy
 00000EC6  66| A1			mov ax, score
	   0000004F R
 00000ECC  E8 00000000 E		call WriteInt
 00000ED1  BA 00000077 R		mov edx, OFFSET strPoints
 00000ED6  E8 00000000 E		call WriteString

 00000EDB  B2 32			mov dl, 50
 00000EDD  B6 12			mov dh, 18
 00000EDF  E8 00000000 E		call Gotoxy
 00000EE4  BA 00000051 R		mov edx, OFFSET strTryAgain
 00000EE9  E8 00000000 E		call WriteString

 00000EEE				retryBody:
 00000EEE  B6 13			mov dh, 19
 00000EF0  B2 38			mov dl, 56
 00000EF2  E8 00000000 E		call Gotoxy
 00000EF7  E8 00000000 E		call ReadInt
 00000EFC  3C 01			cmp al, 1
 00000EFE  0F 84 FFFFF381		je playagn
 00000F04  3C 00			cmp al, 0
 00000F06  0F 84 FFFFF37E		je exitgame

 00000F0C  B6 11			mov dh, 17
 00000F0E  E8 00000000 E		call Gotoxy
 00000F13  BA 00000069 R		mov edx, OFFSET invalidInput
 00000F18  E8 00000000 E		call WriteString
 00000F1D  B2 38			mov dl, 56
 00000F1F  B6 13			mov dh, 19
 00000F21  E8 00000000 E		call Gotoxy
 00000F26  BA 00000081 R		mov edx, OFFSET blank
 00000F2B  E8 00000000 E		call WriteString
 00000F30  EB BC			jmp retryBody
 00000F32			YouDiedBody ENDP

 00000F32			ReinitializeGame PROC            ;procedure to reinitialize everything
				    ; reset snake start position
 00000F32  C6 05 000001B8 R	    mov xPos[0], 45
	   2D
 00000F39  C6 05 000001B9 R	    mov xPos[1], 44
	   2C
 00000F40  C6 05 000001BA R	    mov xPos[2], 43
	   2B
 00000F47  C6 05 000001BB R	    mov xPos[3], 42
	   2A
 00000F4E  C6 05 000001BC R	    mov xPos[4], 41
	   29
 00000F55  C6 05 000003B1 R	    mov yPos[0], 15
	   0F
 00000F5C  C6 05 000003B2 R	    mov yPos[1], 15
	   0F
 00000F63  C6 05 000003B3 R	    mov yPos[2], 15
	   0F
 00000F6A  C6 05 000003B4 R	    mov yPos[3], 15
	   0F
 00000F71  C6 05 000003B5 R	    mov yPos[4], 15
	   0F

 00000F78  66| C7 05		    mov score, 0
	   0000004F R
	   0000
 00000F81  C6 05 000005B5 R	    mov lastInputChar, 0
	   00
 00000F88  C6 05 000005B4 R	    mov inputChar, 0
	   00

				    ; clear single-candidate hazard state
 00000F8F  C6 05 000005CA R	    mov hazardActive, 0
	   00
 00000F96  C6 05 000005CC R	    mov hazardX, 0
	   00
 00000F9D  C6 05 000005CD R	    mov hazardY, 0
	   00
 00000FA4  C6 05 000005CB R	    mov hazardOrient, 0
	   00
 00000FAB  C6 05 000005CE R	    mov hazCount, 0
	   00
 00000FB2  FC			    cld                     ; ensure forward direction for stosb

 00000FB3  B9 00000005		    mov ecx, MAX_HAZARDS
 00000FB8  B0 00		    mov al, 0
 00000FBA  8D 3D 000005CF R	    lea edi, hazXs
 00000FC0  F3/ AA		    rep stosb

 00000FC2  B9 00000005		    mov ecx, MAX_HAZARDS
 00000FC7  B0 00		    mov al, 0
 00000FC9  8D 3D 000005D4 R	    lea edi, hazYs
 00000FCF  F3/ AA		    rep stosb

 00000FD1  B9 00000005		    mov ecx, MAX_HAZARDS
 00000FD6  B0 00		    mov al, 0
 00000FD8  8D 3D 000005D9 R	    lea edi, hazOrients
 00000FDE  F3/ AA		    rep stosb

 00000FE0  E8 00000000 E	    Call ClrScr
 00000FE5  E9 FFFFF016		    jmp main
 00000FEA			ReinitializeGame ENDP

				END main
Microsoft (R) Macro Assembler Version 14.44.35219.0	    11/11/25 10:50:39
snake.asm						     Symbols 2 - 1




Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
FPU_ENVIRON  . . . . . . . . . .	 0000001C
  controlWord  . . . . . . . . .	 00000000	 Word
  statusWord . . . . . . . . . .	 00000004	 Word
  tagWord  . . . . . . . . . . .	 00000008	 Word
  instrPointerOffset . . . . . .	 0000000C	 DWord
  instrPointerSelector . . . . .	 00000010	 DWord
  operandPointerOffset . . . . .	 00000014	 DWord
  operandPointerSelector . . . .	 00000018	 Word
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	 XmmWord
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 000005DE DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000FEA DWord	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

CheckBlockCollision  . . . . . .	P Near	 00000D1C _TEXT	Length= 00000051 Public STDCALL
  CBC_h_loop . . . . . . . . . .	L Near	 00000D35 _TEXT	
  CBC_c_loop . . . . . . . . . .	L Near	 00000D37 _TEXT	
  CBC_vert . . . . . . . . . . .	L Near	 00000D52 _TEXT	
  CBC_have . . . . . . . . . . .	L Near	 00000D54 _TEXT	
  CBC_next_cell  . . . . . . . .	L Near	 00000D61 _TEXT	
  CBC_done . . . . . . . . . . .	L Near	 00000D6C _TEXT	
CheckSnake . . . . . . . . . . .	P Near	 000006A7 _TEXT	Length= 00000042 Public STDCALL
  checkXposition . . . . . . . .	L Near	 000006C6 _TEXT	
  contloop . . . . . . . . . . .	L Near	 000006CE _TEXT	
  XposSame . . . . . . . . . . .	L Near	 000006DB _TEXT	
ClearHazardAt  . . . . . . . . .	P Near	 00000CBE _TEXT	Length= 0000005E Public STDCALL
  CHA_loop . . . . . . . . . . .	L Near	 00000CC7 _TEXT	
  CHA_v  . . . . . . . . . . . .	L Near	 00000CE1 _TEXT	
  CHA_have . . . . . . . . . . .	L Near	 00000CE3 _TEXT	
  CHA_skip . . . . . . . . . . .	L Near	 00000D11 _TEXT	
CloseFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateBetweenOrRandomHazardBlock .	P Near	 00000BAC _TEXT	Length= 000000A0 Public STDCALL
  CBR_h_haveBounds . . . . . . .	L Near	 00000C15 _TEXT	
  CBR_vert_check . . . . . . . .	L Near	 00000C23 _TEXT	
  CBR_v_haveBounds . . . . . . .	L Near	 00000C38 _TEXT	
  CBR_random . . . . . . . . . .	L Near	 00000C46 _TEXT	
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMidpointHazardBlock  . . .	P Near	 0000085C _TEXT	Length= 000001CE Public STDCALL
  V_low_ok . . . . . . . . . . .	L Near	 000008F8 _TEXT	
  V_hi_ok  . . . . . . . . . . .	L Near	 000008FE _TEXT	
  VX_low_ok  . . . . . . . . . .	L Near	 0000091B _TEXT	
  VX_hi_ok . . . . . . . . . . .	L Near	 00000921 _TEXT	
  HZ_mid_horiz . . . . . . . . .	L Near	 00000928 _TEXT	
  H_low_ok . . . . . . . . . . .	L Near	 0000095F _TEXT	
  H_hi_ok  . . . . . . . . . . .	L Near	 00000965 _TEXT	
  HY_low_ok  . . . . . . . . . .	L Near	 00000972 _TEXT	
  HY_hi_ok . . . . . . . . . . .	L Near	 00000978 _TEXT	
  HZ_validate  . . . . . . . . .	L Near	 0000097D _TEXT	
  HZ_cell_loop3  . . . . . . . .	L Near	 0000097F _TEXT	
  HZ_cell_v3 . . . . . . . . . .	L Near	 00000997 _TEXT	
  HZ_cell_have3  . . . . . . . .	L Near	 00000999 _TEXT	
  HZ_snake_scan3 . . . . . . . .	L Near	 000009E3 _TEXT	
  HZ_next_seg3 . . . . . . . . .	L Near	 000009F7 _TEXT	
  HZ_coin_ok3  . . . . . . . . .	L Near	 00000A10 _TEXT	
  HZ_fail2 . . . . . . . . . . .	L Near	 00000A22 _TEXT	
CreateOutputFile . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateRandomCoin . . . . . . . .	P Near	 0000045A _TEXT	Length= 000001AC Public STDCALL
  CR_try_random  . . . . . . . .	L Near	 00000495 _TEXT	
  CR_scan_snake  . . . . . . . .	L Near	 000004CD _TEXT	
  CR_next_seg  . . . . . . . . .	L Near	 000004E9 _TEXT	
  CR_hz_loop . . . . . . . . . .	L Near	 000004FC _TEXT	
  CR_hz_cell_loop  . . . . . . .	L Near	 000004FE _TEXT	
  CR_hz_vert . . . . . . . . . .	L Near	 00000519 _TEXT	
  CR_hz_have . . . . . . . . . .	L Near	 0000051B _TEXT	
  CR_hz_next_cell  . . . . . . .	L Near	 0000052B _TEXT	
  CR_hz_hit_all  . . . . . . . .	L Near	 0000053A _TEXT	
  CR_success . . . . . . . . . .	L Near	 0000053D _TEXT	
  CR_retry_random  . . . . . . .	L Near	 0000053E _TEXT	
  CR_scan_fallback . . . . . . .	L Near	 00000555 _TEXT	
  CR_fb_snake  . . . . . . . . .	L Near	 00000569 _TEXT	
  CR_fb_next_seg . . . . . . . .	L Near	 00000585 _TEXT	
  CR_fb_h_loop . . . . . . . . .	L Near	 00000596 _TEXT	
  CR_fb_h_vert . . . . . . . . .	L Near	 000005AE _TEXT	
  CR_fb_h_have . . . . . . . . .	L Near	 000005B0 _TEXT	
  CR_fb_h_next . . . . . . . . .	L Near	 000005C0 _TEXT	
  CR_fb_h_hit  . . . . . . . . .	L Near	 000005CA _TEXT	
  CR_fb_done . . . . . . . . . .	L Near	 000005CD _TEXT	
  CR_fb_advance  . . . . . . . .	L Near	 000005CE _TEXT	
  CR_set_y . . . . . . . . . . .	L Near	 000005ED _TEXT	
  CR_set_x . . . . . . . . . . .	L Near	 000005F4 _TEXT	
  CR_after_adv . . . . . . . . .	L Near	 000005F9 _TEXT	
CreateRandomHazardBlock  . . . .	P Near	 00000A2A _TEXT	Length= 00000182 Public STDCALL
  CRH_try  . . . . . . . . . . .	L Near	 00000A36 _TEXT	
  CRH_vert . . . . . . . . . . .	L Near	 00000AAC _TEXT	
  CRH_validate . . . . . . . . .	L Near	 00000AEE _TEXT	
  CRH_loop_cells . . . . . . . .	L Near	 00000AF0 _TEXT	
  CRH_v_add  . . . . . . . . . .	L Near	 00000B08 _TEXT	
  CRH_have . . . . . . . . . . .	L Near	 00000B0A _TEXT	
  CRH_snake_scan_cell  . . . . .	L Near	 00000B55 _TEXT	
  CRH_snake_next_cell  . . . . .	L Near	 00000B6F _TEXT	
  CRH_snake_cont_cell  . . . . .	L Near	 00000B70 _TEXT	
  CRH_coin_ok  . . . . . . . . .	L Near	 00000B8A _TEXT	
  CRH_fail_attempt . . . . . . .	L Near	 00000B9D _TEXT	
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DrawBody . . . . . . . . . . . .	P Near	 000006E9 _TEXT	Length= 00000039 Public STDCALL
  printbodyloop  . . . . . . . .	L Near	 000006F6 _TEXT	
DrawCoin . . . . . . . . . . . .	P Near	 0000042D _TEXT	Length= 0000002D Public STDCALL
DrawHazardAt . . . . . . . . . .	P Near	 00000C4C _TEXT	Length= 00000072 Public STDCALL
  DHA_loop . . . . . . . . . . .	L Near	 00000C5F _TEXT	
  DHA_v  . . . . . . . . . . . .	L Near	 00000C79 _TEXT	
  DHA_have . . . . . . . . . . .	L Near	 00000C7B _TEXT	
  DHA_skip . . . . . . . . . . .	L Near	 00000CA9 _TEXT	
DrawPlayer . . . . . . . . . . .	P Near	 000003D7 _TEXT	Length= 00000039 Public STDCALL
DrawScoreboard . . . . . . . . .	P Near	 00000329 _TEXT	Length= 0000004F Public STDCALL
DrawWall . . . . . . . . . . . .	P Near	 00000298 _TEXT	Length= 00000091 Public STDCALL
  L11  . . . . . . . . . . . . .	L Near	 000002EC _TEXT	
  L12  . . . . . . . . . . . . .	L Near	 0000030A _TEXT	
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EatingCoin . . . . . . . . . . .	P Near	 00000722 _TEXT	Length= 00000089 Public STDCALL
  incy . . . . . . . . . . . . .	L Near	 00000764 _TEXT	
  decy . . . . . . . . . . . . .	L Near	 0000076C _TEXT	
  checky . . . . . . . . . . . .	L Near	 00000774 _TEXT	
  incx . . . . . . . . . . . . .	L Near	 0000077E _TEXT	
  decx . . . . . . . . . . . . .	L Near	 00000786 _TEXT	
  continue . . . . . . . . . . .	L Near	 0000078C _TEXT	
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FinishedGame . . . . . . . . . .	P Near	 00000606 _TEXT	Length= 000000A1 Public STDCALL
  retry  . . . . . . . . . . . .	L Near	 00000662 _TEXT	
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MaybeSpawnHazardBlock  . . . . .	P Near	 000007AB _TEXT	Length= 000000B1 Public STDCALL
  MSP_shift  . . . . . . . . . .	L Near	 000007F0 _TEXT	
  MSP_space  . . . . . . . . . .	L Near	 0000081E _TEXT	
  MSP_done . . . . . . . . . . .	L Near	 0000085B _TEXT	
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenInputFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseInteger32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKey  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReinitializeGame . . . . . . . .	P Near	 00000F32 _TEXT	Length= 000000B8 Public STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowSpeed  . . . . . . . . . . .	P Near	 00000378 _TEXT	Length= 00000034 Public STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UpdatePlayer . . . . . . . . . .	P Near	 00000410 _TEXT	Length= 0000001D Public STDCALL
UpdateSpeed  . . . . . . . . . .	P Near	 000003AC _TEXT	Length= 0000002B Public STDCALL
  skipUpdate . . . . . . . . . .	L Near	 000003D6 _TEXT	
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrameName  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrame  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteToFile  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
YouDiedBody  . . . . . . . . . .	P Near	 00000E9B _TEXT	Length= 00000097 Public STDCALL
  retryBody  . . . . . . . . . .	L Near	 00000EEE _TEXT	
YouDiedHazard  . . . . . . . . .	P Near	 00000D6D _TEXT	Length= 00000097 Public STDCALL
  retryHaz . . . . . . . . . . .	L Near	 00000DC0 _TEXT	
YouDiedWall  . . . . . . . . . .	P Near	 00000E04 _TEXT	Length= 00000097 Public STDCALL
  retryWall  . . . . . . . . . .	L Near	 00000E57 _TEXT	
main . . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000298 Public STDCALL
  drawSnake  . . . . . . . . . .	L Near	 0000001E _TEXT	
  noKey  . . . . . . . . . . . .	L Near	 00000051 _TEXT	
  checkBottom  . . . . . . . . .	L Near	 00000088 _TEXT	
  checkLeft  . . . . . . . . . .	L Near	 000000B6 _TEXT	
  checkRight . . . . . . . . . .	L Near	 000000F1 _TEXT	
  checkTop . . . . . . . . . . .	L Near	 0000011F _TEXT	
  moveUp . . . . . . . . . . . .	L Near	 00000149 _TEXT	
  moveDown . . . . . . . . . . .	L Near	 00000183 _TEXT	
  moveLeft . . . . . . . . . . .	L Near	 000001BD _TEXT	
  moveRight  . . . . . . . . . .	L Near	 000001F7 _TEXT	
  dontChgDirection . . . . . . .	L Near	 00000264 _TEXT	
  dontGoLeft . . . . . . . . . .	L Near	 0000026F _TEXT	
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HAZARD_CLOSE_DIST  . . . . . . .	Number	 00000006h   
HAZARD_LEN . . . . . . . . . . .	Number	 0000000Fh   
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
MAX_HAZARDS  . . . . . . . . . .	Number	 00000005h   
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
baseSpeed  . . . . . . . . . . .	DWord	 000005B6 _DATA	
black  . . . . . . . . . . . . .	Number	 00000000h   
blank  . . . . . . . . . . . . .	Byte	 00000081 _DATA	
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
checkcoin  . . . . . . . . . . .	L Near	 00000231 _TEXT	
cyan . . . . . . . . . . . . . .	Number	 00000003h   
diedBody . . . . . . . . . . . .	L Near	 00000280 _TEXT	
diedWall . . . . . . . . . . . .	L Near	 0000027B _TEXT	
exitgame . . . . . . . . . . . .	L Near	 0000028A _TEXT	
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
gameLoop . . . . . . . . . . . .	L Near	 00000030 _TEXT	
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
hazCount . . . . . . . . . . . .	Byte	 000005CE _DATA	
hazOrients . . . . . . . . . . .	Byte	 000005D9 _DATA	
hazXs  . . . . . . . . . . . . .	Byte	 000005CF _DATA	
hazYs  . . . . . . . . . . . . .	Byte	 000005D4 _DATA	
hazardActive . . . . . . . . . .	Byte	 000005CA _DATA	
hazardOrient . . . . . . . . . .	Byte	 000005CB _DATA	
hazardX  . . . . . . . . . . . .	Byte	 000005CC _DATA	
hazardY  . . . . . . . . . . . .	Byte	 000005CD _DATA	
inputChar  . . . . . . . . . . .	Byte	 000005B4 _DATA	
invalidInput . . . . . . . . . .	Byte	 00000069 _DATA	
lastInputChar  . . . . . . . . .	Byte	 000005B5 _DATA	
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
magenta  . . . . . . . . . . . .	Number	 00000005h   
playagn  . . . . . . . . . . . .	L Near	 00000285 _TEXT	
red  . . . . . . . . . . . . . .	Number	 00000004h   
score  . . . . . . . . . . . . .	Word	 0000004F _DATA	
snakeBodyInit  . . . . . . . . .	DWord	 000001B4 _DATA	
snake  . . . . . . . . . . . . .	Byte	 0000014B _DATA	
speed  . . . . . . . . . . . . .	DWord	 000005BE _DATA	
strBodyDeath . . . . . . . . . .	Byte	 000000C3 _DATA	
strCollision . . . . . . . . . .	Byte	 000000DA _DATA	
strFinishedGame  . . . . . . . .	Byte	 000000F4 _DATA	
strNoMoreSpace . . . . . . . . .	Byte	 0000011C _DATA	
strPoints  . . . . . . . . . . .	Byte	 00000077 _DATA	
strScore . . . . . . . . . . . .	Byte	 00000047 _DATA	
strSpeed . . . . . . . . . . . .	Byte	 000005C2 _DATA	
strTryAgain  . . . . . . . . . .	Byte	 00000051 _DATA	
strWallDeath . . . . . . . . . .	Byte	 000000B1 _DATA	
titleName  . . . . . . . . . . .	Byte	 000000A7 _DATA	
topSpeed . . . . . . . . . . . .	DWord	 000005BA _DATA	
wallChar . . . . . . . . . . . .	Number	 000000DBh   
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
xCoinPos . . . . . . . . . . . .	Byte	 000005B2 _DATA	
xPosWall . . . . . . . . . . . .	Byte	 000005AA _DATA	
xPos . . . . . . . . . . . . . .	Byte	 000001B8 _DATA	
xWall  . . . . . . . . . . . . .	Byte	 00000000 _DATA	
yCoinPos . . . . . . . . . . . .	Byte	 000005B3 _DATA	
yPosWall . . . . . . . . . . . .	Byte	 000005AE _DATA	
yPos . . . . . . . . . . . . . .	Byte	 000003B1 _DATA	
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   1 Warnings
	   0 Errors
